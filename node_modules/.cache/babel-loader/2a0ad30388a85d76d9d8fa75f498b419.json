{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"rive\"] = factory();else root[\"rive\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    (() => {\n      // webpackBootstrap\n\n      /******/\n      \"use strict\";\n      /******/\n\n      var __webpack_modules__ = [\n        /* 0 */\n      ,\n      /* 1 */\n\n      /***/\n      (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export */\n\n\n        __webpack_require__.d(__webpack_exports__, {\n          /* harmony export */\n          \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n          /* harmony export */\n\n        });\n\n        var Rive = (() => {\n          var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n\n          return function (Rive) {\n            Rive = Rive || {};\n            null;\n            var m;\n            m || (m = typeof Rive !== 'undefined' ? Rive : {});\n            var aa, ba;\n            m.ready = new Promise(function (b, a) {\n              aa = b;\n              ba = a;\n            });\n\n            function ca() {\n              function b(h) {\n                const g = d;\n                c = a = 0;\n                d = new Map();\n                g.forEach(l => {\n                  try {\n                    l(h);\n                  } catch (k) {\n                    console.error(k);\n                  }\n                });\n                this.La();\n                e && e.fb();\n              }\n\n              let a = 0,\n                  c = 0,\n                  d = new Map(),\n                  e = null,\n                  f = null;\n\n              this.requestAnimationFrame = function (h) {\n                a || (a = requestAnimationFrame(b.bind(this)));\n                const g = ++c;\n                d.set(g, h);\n                return g;\n              };\n\n              this.cancelAnimationFrame = function (h) {\n                d.delete(h);\n                a && 0 == d.size && (cancelAnimationFrame(a), a = 0);\n              };\n\n              this.cb = function (h) {\n                f && (document.body.remove(f), f = null);\n                h || (f = document.createElement(\"div\"), f.style.backgroundColor = \"black\", f.style.position = \"fixed\", f.style.right = 0, f.style.top = 0, f.style.color = \"white\", f.style.padding = \"4px\", f.innerHTML = \"RIVE FPS\", h = function (g) {\n                  f.innerHTML = \"RIVE FPS \" + g.toFixed(1);\n                }, document.body.appendChild(f));\n                e = new function () {\n                  let g = 0,\n                      l = 0;\n\n                  this.fb = function () {\n                    var k = performance.now();\n                    l ? (++g, k -= l, 1E3 < k && (h(1E3 * g / k), g = l = 0)) : (l = k, g = 0);\n                  };\n                }();\n              };\n\n              this.$a = function () {\n                f && (document.body.remove(f), f = null);\n                e = null;\n              };\n\n              this.La = function () {};\n            }\n\n            function ea(b) {\n              console.assert(!0);\n              const a = new Map();\n              let c = -Infinity;\n\n              this.push = function (d) {\n                d = d + ((1 << b) - 1) >> b;\n                a.has(d) && clearTimeout(a.get(d));\n                a.set(d, setTimeout(function () {\n                  a.delete(d);\n                  0 == a.length ? c = -Infinity : d == c && (c = Math.max(...a.keys()), console.assert(c < d));\n                }, 1E3));\n                c = Math.max(d, c);\n                return c << b;\n              };\n            }\n\n            const fa = new function () {\n              function b() {\n                if (!a) {\n                  var t = document.createElement(\"canvas\"),\n                      v = {\n                    alpha: 1,\n                    depth: 0,\n                    stencil: 0,\n                    antialias: 0,\n                    premultipliedAlpha: 1,\n                    preserveDrawingBuffer: 0,\n                    preferLowPowerToHighPerformance: 0,\n                    failIfMajorPerformanceCaveat: 0,\n                    enableExtensionsByDefault: 1,\n                    explicitSwapControl: 1,\n                    renderViaOffscreenBackBuffer: 1\n                  };\n                  let q = t.getContext(\"webgl2\", v);\n                  if (q) c = 2;else if (q = t.getContext(\"webgl\", v)) c = 1;else return console.log(\"No WebGL support. Image mesh will not be drawn.\"), !1;\n                  d = Math.min(q.getParameter(q.MAX_RENDERBUFFER_SIZE), q.getParameter(q.MAX_TEXTURE_SIZE));\n\n                  function E(I, w, z) {\n                    w = q.createShader(w);\n                    q.shaderSource(w, z);\n                    q.compileShader(w);\n                    z = q.getShaderInfoLog(w);\n                    if (0 < z.length) throw z;\n                    q.attachShader(I, w);\n                  }\n\n                  t = q.createProgram();\n                  E(t, q.VERTEX_SHADER, \"attribute vec2 vertex;\\n                attribute vec2 uv;\\n                uniform vec4 mat;\\n                uniform vec2 translate;\\n                varying vec2 st;\\n                void main() {\\n                    st = uv;\\n                    gl_Position = vec4(mat2(mat) * vertex + translate, 0, 1);\\n                }\");\n                  E(t, q.FRAGMENT_SHADER, \"precision highp float;\\n                uniform sampler2D image;\\n                varying vec2 st;\\n                void main() {\\n                    gl_FragColor = texture2D(image, st);\\n                }\");\n                  q.bindAttribLocation(t, 0, \"vertex\");\n                  q.bindAttribLocation(t, 1, \"uv\");\n                  q.linkProgram(t);\n                  v = q.getProgramInfoLog(t);\n                  if (0 < v.length) throw v;\n                  e = q.getUniformLocation(t, \"mat\");\n                  f = q.getUniformLocation(t, \"translate\");\n                  q.useProgram(t);\n                  q.bindBuffer(q.ARRAY_BUFFER, q.createBuffer());\n                  q.enableVertexAttribArray(0);\n                  q.enableVertexAttribArray(1);\n                  q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, q.createBuffer());\n                  q.uniform1i(q.getUniformLocation(t, \"image\"), 0);\n                  q.pixelStorei(q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);\n                  a = q;\n                }\n\n                return !0;\n              }\n\n              let a = null,\n                  c = 0,\n                  d = 0,\n                  e = null,\n                  f = null,\n                  h = 0,\n                  g = 0;\n\n              this.ob = function () {\n                b();\n                return d;\n              };\n\n              this.Ya = function (t) {\n                if (!b()) return null;\n                const v = a.createTexture();\n                a.bindTexture(a.TEXTURE_2D, v);\n                a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, a.RGBA, a.UNSIGNED_BYTE, t);\n                a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);\n                a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);\n                a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR);\n                2 == c ? (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_LINEAR), a.generateMipmap(a.TEXTURE_2D)) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);\n                return v;\n              };\n\n              const l = new ea(8),\n                    k = new ea(8),\n                    p = new ea(10),\n                    r = new ea(10);\n\n              this.bb = function (t, v, q, E, I) {\n                if (b()) {\n                  var w = l.push(t),\n                      z = k.push(v);\n                  if (a.canvas.width != w || a.canvas.height != z) a.canvas.width = w, a.canvas.height = z;\n                  a.viewport(0, z - v, t, v);\n                  a.disable(a.SCISSOR_TEST);\n                  a.clearColor(0, 0, 0, 0);\n                  a.clear(a.COLOR_BUFFER_BIT);\n                  a.enable(a.SCISSOR_TEST);\n                  q.sort((y, da) => da.Oa - y.Oa);\n                  w = p.push(E);\n                  h != w && (a.bufferData(a.ARRAY_BUFFER, 8 * w, a.DYNAMIC_DRAW), h = w);\n                  w = 0;\n\n                  for (var J of q) a.bufferSubData(a.ARRAY_BUFFER, w, J.Aa), w += 4 * J.Aa.length;\n\n                  console.assert(w == 4 * E);\n\n                  for (var P of q) a.bufferSubData(a.ARRAY_BUFFER, w, P.Ra), w += 4 * P.Ra.length;\n\n                  console.assert(w == 8 * E);\n                  w = r.push(I);\n                  g != w && (a.bufferData(a.ELEMENT_ARRAY_BUFFER, 2 * w, a.DYNAMIC_DRAW), g = w);\n                  J = 0;\n\n                  for (var X of q) a.bufferSubData(a.ELEMENT_ARRAY_BUFFER, J, X.indices), J += 2 * X.indices.length;\n\n                  console.assert(J == 2 * I);\n                  X = 0;\n                  P = !0;\n                  w = J = 0;\n\n                  for (const y of q) {\n                    y.image.va != X && (a.bindTexture(a.TEXTURE_2D, y.image.Va || null), X = y.image.va);\n                    y.rb ? (a.scissor(y.Ea, z - y.Fa - y.Ka, y.yb, y.Ka), P = !0) : P && (a.scissor(0, z - v, t, v), P = !1);\n                    q = 2 / t;\n                    const da = -2 / v;\n                    a.uniform4f(e, y.la[0] * q * y.ra, y.la[1] * da * y.sa, y.la[2] * q * y.ra, y.la[3] * da * y.sa);\n                    a.uniform2f(f, y.la[4] * q * y.ra + q * (y.Ea - y.pb * y.ra) - 1, y.la[5] * da * y.sa + da * (y.Fa - y.qb * y.sa) + 1);\n                    a.vertexAttribPointer(0, 2, a.FLOAT, !1, 0, w);\n                    a.vertexAttribPointer(1, 2, a.FLOAT, !1, 0, w + 4 * E);\n                    a.drawElements(a.TRIANGLES, y.indices.length, a.UNSIGNED_SHORT, J);\n                    w += 4 * y.Aa.length;\n                    J += 2 * y.indices.length;\n                  }\n\n                  console.assert(w == 4 * E);\n                  console.assert(J == 2 * I);\n                }\n              };\n\n              this.canvas = function () {\n                return b() && a.canvas;\n              };\n            }();\n\n            Rive.onRuntimeInitialized = function () {\n              function b(n) {\n                switch (n) {\n                  case k.srcOver:\n                    return \"source-over\";\n\n                  case k.screen:\n                    return \"screen\";\n\n                  case k.overlay:\n                    return \"overlay\";\n\n                  case k.darken:\n                    return \"darken\";\n\n                  case k.lighten:\n                    return \"lighten\";\n\n                  case k.colorDodge:\n                    return \"color-dodge\";\n\n                  case k.colorBurn:\n                    return \"color-burn\";\n\n                  case k.hardLight:\n                    return \"hard-light\";\n\n                  case k.softLight:\n                    return \"soft-light\";\n\n                  case k.difference:\n                    return \"difference\";\n\n                  case k.exclusion:\n                    return \"exclusion\";\n\n                  case k.multiply:\n                    return \"multiply\";\n\n                  case k.hue:\n                    return \"hue\";\n\n                  case k.saturation:\n                    return \"saturation\";\n\n                  case k.color:\n                    return \"color\";\n\n                  case k.luminosity:\n                    return \"luminosity\";\n                }\n              }\n\n              function a(n) {\n                return \"rgba(\" + ((16711680 & n) >>> 16) + \",\" + ((65280 & n) >>> 8) + \",\" + ((255 & n) >>> 0) + \",\" + ((4278190080 & n) >>> 24) / 255 + \")\";\n              }\n\n              function c() {\n                0 < J.length && (fa.bb(z.drawWidth(), z.drawHeight(), J, P, X), J = [], X = P = 0, z.reset(512, 512));\n\n                for (const n of w) {\n                  for (const u of n.da) u();\n\n                  n.da = [];\n                }\n\n                w.clear();\n              }\n\n              var d = Rive.RenderPaintStyle;\n              const e = Rive.RenderPath,\n                    f = Rive.RenderPaint,\n                    h = Rive.Renderer,\n                    g = Rive.StrokeCap,\n                    l = Rive.StrokeJoin,\n                    k = Rive.BlendMode,\n                    p = d.fill,\n                    r = d.stroke,\n                    t = Rive.FillRule.evenOdd;\n              let v = 1;\n              var q = Rive.RenderImage.extend(\"CanvasRenderImage\", {\n                __construct: function () {\n                  this.__parent.__construct.call(this);\n\n                  this.va = v;\n                  v = v + 1 & 2147483647 || 1;\n                },\n                decode: function (n) {\n                  let u = Xa;\n                  u.total++;\n                  var F = this,\n                      B = new Image();\n                  B.src = URL.createObjectURL(new Blob([n], {\n                    type: \"image/png\"\n                  }));\n\n                  B.onload = function () {\n                    F.Ta = B;\n                    F.Va = fa.Ya(B);\n                    F.size(B.width, B.height);\n                    u.loaded++;\n\n                    if (u.loaded === u.total) {\n                      const D = u.ready;\n                      D && (D(), u.ready = null);\n                    }\n                  };\n                }\n              }),\n                  E = e.extend(\"CanvasRenderPath\", {\n                __construct: function () {\n                  this.__parent.__construct.call(this);\n\n                  this.ga = new Path2D();\n                },\n                reset: function () {\n                  this.ga = new Path2D();\n                },\n                addPath: function (n, u, F, B, D, G, A) {\n                  var C = this.ga,\n                      R = C.addPath;\n                  n = n.ga;\n                  const K = new DOMMatrix();\n                  K.a = u;\n                  K.b = F;\n                  K.c = B;\n                  K.d = D;\n                  K.e = G;\n                  K.f = A;\n                  R.call(C, n, K);\n                },\n                fillRule: function (n) {\n                  this.Ca = n;\n                },\n                moveTo: function (n, u) {\n                  this.ga.moveTo(n, u);\n                },\n                lineTo: function (n, u) {\n                  this.ga.lineTo(n, u);\n                },\n                cubicTo: function (n, u, F, B, D, G) {\n                  this.ga.bezierCurveTo(n, u, F, B, D, G);\n                },\n                close: function () {\n                  this.ga.closePath();\n                }\n              }),\n                  I = f.extend(\"CanvasRenderPaint\", {\n                color: function (n) {\n                  this.Da = a(n);\n                },\n                thickness: function (n) {\n                  this.Wa = n;\n                },\n                join: function (n) {\n                  switch (n) {\n                    case l.miter:\n                      this.ua = \"miter\";\n                      break;\n\n                    case l.round:\n                      this.ua = \"round\";\n                      break;\n\n                    case l.bevel:\n                      this.ua = \"bevel\";\n                  }\n                },\n                cap: function (n) {\n                  switch (n) {\n                    case g.butt:\n                      this.ta = \"butt\";\n                      break;\n\n                    case g.round:\n                      this.ta = \"round\";\n                      break;\n\n                    case g.square:\n                      this.ta = \"square\";\n                  }\n                },\n                style: function (n) {\n                  this.Ua = n;\n                },\n                blendMode: function (n) {\n                  this.Sa = b(n);\n                },\n                linearGradient: function (n, u, F, B) {\n                  this.oa = {\n                    Pa: n,\n                    Qa: u,\n                    Ha: F,\n                    Ia: B,\n                    za: []\n                  };\n                },\n                radialGradient: function (n, u, F, B) {\n                  this.oa = {\n                    Pa: n,\n                    Qa: u,\n                    Ha: F,\n                    Ia: B,\n                    za: [],\n                    mb: !0\n                  };\n                },\n                addStop: function (n, u) {\n                  this.oa.za.push({\n                    color: n,\n                    stop: u\n                  });\n                },\n                completeGradient: function () {},\n                draw: function (n, u, F) {\n                  let B = this.Ua;\n                  var D = this.Da,\n                      G = this.oa;\n                  n.globalCompositeOperation = this.Sa;\n\n                  if (null != G) {\n                    D = G.Pa;\n                    var A = G.Qa;\n                    const R = G.Ha;\n                    var C = G.Ia;\n                    const K = G.za;\n                    G.mb ? (G = R - D, C -= A, D = n.createRadialGradient(D, A, 0, D, A, Math.sqrt(G * G + C * C))) : D = n.createLinearGradient(D, A, R, C);\n\n                    for (let U = 0, L = K.length; U < L; U++) A = K[U], D.addColorStop(A.stop, a(A.color));\n\n                    this.Da = D;\n                    this.oa = null;\n                  }\n\n                  switch (B) {\n                    case r:\n                      n.strokeStyle = D;\n                      n.lineWidth = this.Wa;\n                      n.lineCap = this.ta;\n                      n.lineJoin = this.ua;\n                      n.stroke(u);\n                      break;\n\n                    case p:\n                      n.fillStyle = D, n.fill(u, F);\n                  }\n                }\n              });\n              const w = new Set();\n              let z = null,\n                  J = [],\n                  P = 0,\n                  X = 0;\n              var y = Rive.CanvasRenderer = h.extend(\"Renderer\", {\n                __construct: function (n) {\n                  this.__parent.__construct.call(this);\n\n                  this.fa = [1, 0, 0, 1, 0, 0];\n                  this.Z = n.getContext(\"2d\");\n                  this.Ba = n;\n                  this.da = [];\n                },\n                save: function () {\n                  this.fa.push(...this.fa.slice(this.fa.length - 6));\n                  this.da.push(this.Z.save.bind(this.Z));\n                },\n                restore: function () {\n                  const n = this.fa.length - 6;\n                  if (6 > n) throw \"restore() called without matching save().\";\n                  this.fa.splice(n);\n                  this.da.push(this.Z.restore.bind(this.Z));\n                },\n                transform: function (n, u, F, B, D, G) {\n                  const A = this.fa,\n                        C = A.length - 6;\n                  A.splice(C, 6, A[C] * n + A[C + 2] * u, A[C + 1] * n + A[C + 3] * u, A[C] * F + A[C + 2] * B, A[C + 1] * F + A[C + 3] * B, A[C] * D + A[C + 2] * G + A[C + 4], A[C + 1] * D + A[C + 3] * G + A[C + 5]);\n                  this.da.push(this.Z.transform.bind(this.Z, n, u, F, B, D, G));\n                },\n                rotate: function (n) {\n                  const u = Math.sin(n);\n                  n = Math.cos(n);\n                  this.transform(n, u, -u, n, 0, 0);\n                },\n                _drawPath: function (n, u) {\n                  this.da.push(u.draw.bind(u, this.Z, n.ga, n.Ca === t ? \"evenodd\" : \"nonzero\"));\n                },\n                _drawImage: function (n, u, F) {\n                  var B = n.Ta;\n\n                  if (B) {\n                    var D = this.Z,\n                        G = b(u);\n                    this.da.push(function () {\n                      D.globalCompositeOperation = G;\n                      D.globalAlpha = F;\n                      D.drawImage(B, 0, 0);\n                      D.globalAlpha = 1;\n                    });\n                  }\n                },\n                _getMatrix: function (n) {\n                  const u = this.fa,\n                        F = u.length - 6;\n\n                  for (let B = 0; 6 > B; ++B) n[B] = u[F + B];\n                },\n                _drawImageMesh: function (n, u, F, B, D, G, A, C, R, K) {\n                  var U = this.Z.canvas.width,\n                      L = this.Z.canvas.height;\n                  const pb = R - A,\n                        qb = K - C;\n                  A = Math.max(A, 0);\n                  C = Math.max(C, 0);\n                  R = Math.min(R, U);\n                  K = Math.min(K, L);\n                  const sa = R - A,\n                        ta = K - C;\n                  console.assert(sa <= Math.min(pb, U));\n                  console.assert(ta <= Math.min(qb, L));\n\n                  if (!(0 >= sa || 0 >= ta)) {\n                    R = sa < pb || ta < qb;\n                    U = K = 1;\n                    var ia = Math.ceil(sa * K),\n                        ja = Math.ceil(ta * U);\n                    L = fa.ob();\n                    ia > L && (K *= L / ia, ia = L);\n                    ja > L && (U *= L / ja, ja = L);\n                    z || (z = new m.DynamicRectanizer(L), z.reset(512, 512));\n                    L = z.addRect(ia, ja);\n                    0 > L && (c(), w.add(this), L = z.addRect(ia, ja), console.assert(0 <= L));\n                    var rb = L & 65535,\n                        sb = L >> 16;\n                    J.push({\n                      la: this.fa.slice(this.fa.length - 6),\n                      image: n,\n                      Ea: rb,\n                      Fa: sb,\n                      pb: A,\n                      qb: C,\n                      yb: ia,\n                      Ka: ja,\n                      ra: K,\n                      sa: U,\n                      Aa: new Float32Array(B),\n                      Ra: new Float32Array(D),\n                      indices: new Uint16Array(G),\n                      rb: R,\n                      Oa: n.va << 1 | (R ? 1 : 0)\n                    });\n                    P += B.length;\n                    X += G.length;\n                    var na = this.Z,\n                        Yb = b(u);\n                    this.da.push(function () {\n                      na.save();\n                      na.resetTransform();\n                      na.globalCompositeOperation = Yb;\n                      na.globalAlpha = F;\n                      na.drawImage(fa.canvas(), rb, sb, ia, ja, A, C, sa, ta);\n                      na.restore();\n                    });\n                  }\n                },\n                _clipPath: function (n) {\n                  this.da.push(this.Z.clip.bind(this.Z, n.ga, n.Ca === t ? \"evenodd\" : \"nonzero\"));\n                },\n                clear: function () {\n                  w.add(this);\n                  this.da.push(this.Z.clearRect.bind(this.Z, 0, 0, this.Ba.width, this.Ba.height));\n                },\n                flush: function () {},\n                translate: function (n, u) {\n                  this.transform(1, 0, 0, 1, n, u);\n                }\n              });\n\n              Rive.makeRenderer = function (n) {\n                return new y(n);\n              };\n\n              Rive.renderFactory = {\n                makeRenderPaint: function () {\n                  return new I();\n                },\n                makeRenderPath: function () {\n                  return new E();\n                },\n                makeRenderImage: function () {\n                  return new q();\n                }\n              };\n              let da = Rive.load,\n                  Xa = null;\n\n              Rive.load = function (n) {\n                return new Promise(function (u) {\n                  let F = null;\n                  Xa = {\n                    total: 0,\n                    loaded: 0,\n                    ready: function () {\n                      u(F);\n                    }\n                  };\n                  F = da(n);\n                  0 == Xa.total && u(F);\n                });\n              };\n\n              d = new ca();\n              Rive.requestAnimationFrame = d.requestAnimationFrame.bind(d);\n              Rive.cancelAnimationFrame = d.cancelAnimationFrame.bind(d);\n              Rive.enableFPSCounter = d.cb.bind(d);\n              Rive.disableFPSCounter = d.$a;\n              d.La = c;\n\n              Rive.cleanup = function () {\n                z && z.delete();\n              };\n            };\n\n            var ha = Object.assign({}, m),\n                ka = \"object\" == typeof window,\n                la = \"function\" == typeof importScripts,\n                x = \"\",\n                ma,\n                oa;\n            if (ka || la) la ? x = self.location.href : \"undefined\" != typeof document && document.currentScript && (x = document.currentScript.src), _scriptDir && (x = _scriptDir), 0 !== x.indexOf(\"blob:\") ? x = x.substr(0, x.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1) : x = \"\", la && (oa = b => {\n              var a = new XMLHttpRequest();\n              a.open(\"GET\", b, !1);\n              a.responseType = \"arraybuffer\";\n              a.send(null);\n              return new Uint8Array(a.response);\n            }), ma = (b, a, c) => {\n              var d = new XMLHttpRequest();\n              d.open(\"GET\", b, !0);\n              d.responseType = \"arraybuffer\";\n\n              d.onload = () => {\n                200 == d.status || 0 == d.status && d.response ? a(d.response) : c();\n              };\n\n              d.onerror = c;\n              d.send(null);\n            };\n            var pa = m.print || console.log.bind(console),\n                qa = m.printErr || console.warn.bind(console);\n            Object.assign(m, ha);\n            ha = null;\n            var ra;\n            m.wasmBinary && (ra = m.wasmBinary);\n            var noExitRuntime = m.noExitRuntime || !0;\n            \"object\" != typeof WebAssembly && ua(\"no native wasm support detected\");\n            var va,\n                wa = !1,\n                xa = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : void 0;\n\n            function ya(b, a, c) {\n              var d = a + c;\n\n              for (c = a; b[c] && !(c >= d);) ++c;\n\n              if (16 < c - a && b.buffer && xa) return xa.decode(b.subarray(a, c));\n\n              for (d = \"\"; a < c;) {\n                var e = b[a++];\n\n                if (e & 128) {\n                  var f = b[a++] & 63;\n                  if (192 == (e & 224)) d += String.fromCharCode((e & 31) << 6 | f);else {\n                    var h = b[a++] & 63;\n                    e = 224 == (e & 240) ? (e & 15) << 12 | f << 6 | h : (e & 7) << 18 | f << 12 | h << 6 | b[a++] & 63;\n                    65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));\n                  }\n                } else d += String.fromCharCode(e);\n              }\n\n              return d;\n            }\n\n            var za, Aa, H, Ba, Ca, Da, M, Ea, Fa;\n\n            function Ga() {\n              var b = va.buffer;\n              za = b;\n              m.HEAP8 = Aa = new Int8Array(b);\n              m.HEAP16 = Ba = new Int16Array(b);\n              m.HEAP32 = Da = new Int32Array(b);\n              m.HEAPU8 = H = new Uint8Array(b);\n              m.HEAPU16 = Ca = new Uint16Array(b);\n              m.HEAPU32 = M = new Uint32Array(b);\n              m.HEAPF32 = Ea = new Float32Array(b);\n              m.HEAPF64 = Fa = new Float64Array(b);\n            }\n\n            var Ha,\n                Ia = [],\n                Ja = [],\n                Ka = [];\n\n            function La() {\n              var b = m.preRun.shift();\n              Ia.unshift(b);\n            }\n\n            var Ma = 0,\n                Na = null,\n                Oa = null;\n\n            function ua(b) {\n              if (m.onAbort) m.onAbort(b);\n              b = \"Aborted(\" + b + \")\";\n              qa(b);\n              wa = !0;\n              b = new WebAssembly.RuntimeError(b + \". Build with -sASSERTIONS for more info.\");\n              ba(b);\n              throw b;\n            }\n\n            function Pa() {\n              return N.startsWith(\"data:application/octet-stream;base64,\");\n            }\n\n            var N;\n            N = \"canvas_advanced.wasm\";\n\n            if (!Pa()) {\n              var Qa = N;\n              N = m.locateFile ? m.locateFile(Qa, x) : x + Qa;\n            }\n\n            function Ra() {\n              var b = N;\n\n              try {\n                if (b == N && ra) return new Uint8Array(ra);\n                if (oa) return oa(b);\n                throw \"both async and sync fetching of the wasm failed\";\n              } catch (a) {\n                ua(a);\n              }\n            }\n\n            function Sa() {\n              if (!ra && (ka || la)) {\n                if (\"function\" == typeof fetch && !N.startsWith(\"file://\")) return fetch(N, {\n                  credentials: \"same-origin\"\n                }).then(function (b) {\n                  if (!b.ok) throw \"failed to load wasm binary file at '\" + N + \"'\";\n                  return b.arrayBuffer();\n                }).catch(function () {\n                  return Ra();\n                });\n                if (ma) return new Promise(function (b, a) {\n                  ma(N, function (c) {\n                    b(new Uint8Array(c));\n                  }, a);\n                });\n              }\n\n              return Promise.resolve().then(function () {\n                return Ra();\n              });\n            }\n\n            function Ta(b) {\n              for (; 0 < b.length;) b.shift()(m);\n            }\n\n            function Ua(b) {\n              if (void 0 === b) return \"_unknown\";\n              b = b.replace(/[^a-zA-Z0-9_]/g, \"$\");\n              var a = b.charCodeAt(0);\n              return 48 <= a && 57 >= a ? \"_\" + b : b;\n            }\n\n            function Va(b, a) {\n              b = Ua(b);\n              return function () {\n                null;\n                return a.apply(this, arguments);\n              };\n            }\n\n            var O = [{}, {\n              value: void 0\n            }, {\n              value: null\n            }, {\n              value: !0\n            }, {\n              value: !1\n            }],\n                Wa = [];\n\n            function Ya(b) {\n              var a = Error,\n                  c = Va(b, function (d) {\n                this.name = b;\n                this.message = d;\n                d = Error(d).stack;\n                void 0 !== d && (this.stack = this.toString() + \"\\n\" + d.replace(/^Error(:[^\\n]*)?\\n/, \"\"));\n              });\n              c.prototype = Object.create(a.prototype);\n              c.prototype.constructor = c;\n\n              c.prototype.toString = function () {\n                return void 0 === this.message ? this.name : this.name + \": \" + this.message;\n              };\n\n              return c;\n            }\n\n            var Za = void 0;\n\n            function Q(b) {\n              throw new Za(b);\n            }\n\n            var $a = b => {\n              b || Q(\"Cannot use deleted val. handle = \" + b);\n              return O[b].value;\n            },\n                S = b => {\n              switch (b) {\n                case void 0:\n                  return 1;\n\n                case null:\n                  return 2;\n\n                case !0:\n                  return 3;\n\n                case !1:\n                  return 4;\n\n                default:\n                  var a = Wa.length ? Wa.pop() : O.length;\n                  O[a] = {\n                    ya: 1,\n                    value: b\n                  };\n                  return a;\n              }\n            },\n                ab = void 0,\n                bb = void 0;\n\n            function T(b) {\n              for (var a = \"\"; H[b];) a += bb[H[b++]];\n\n              return a;\n            }\n\n            var cb = [];\n\n            function db() {\n              for (; cb.length;) {\n                var b = cb.pop();\n                b.U.ka = !1;\n                b[\"delete\"]();\n              }\n            }\n\n            var eb = void 0,\n                V = {};\n\n            function fb(b, a) {\n              for (void 0 === a && Q(\"ptr should not be undefined\"); b.$;) a = b.na(a), b = b.$;\n\n              return a;\n            }\n\n            var gb = {};\n\n            function hb(b) {\n              b = ib(b);\n              var a = T(b);\n              jb(b);\n              return a;\n            }\n\n            function kb(b, a) {\n              var c = gb[b];\n              void 0 === c && Q(a + \" has unknown type \" + hb(b));\n              return c;\n            }\n\n            function lb() {}\n\n            var mb = !1;\n\n            function nb(b) {\n              --b.count.value;\n              0 === b.count.value && (b.aa ? b.ca.ha(b.aa) : b.X.V.ha(b.W));\n            }\n\n            function ob(b, a, c) {\n              if (a === c) return b;\n              if (void 0 === c.$) return null;\n              b = ob(b, a, c.$);\n              return null === b ? null : c.ab(b);\n            }\n\n            var tb = {};\n\n            function ub(b, a) {\n              a = fb(b, a);\n              return V[a];\n            }\n\n            var vb = void 0;\n\n            function wb(b) {\n              throw new vb(b);\n            }\n\n            function xb(b, a) {\n              a.X && a.W || wb(\"makeClassHandle requires ptr and ptrType\");\n              !!a.ca !== !!a.aa && wb(\"Both smartPtrType and smartPtr must be specified\");\n              a.count = {\n                value: 1\n              };\n              return yb(Object.create(b, {\n                U: {\n                  value: a\n                }\n              }));\n            }\n\n            function yb(b) {\n              if (\"undefined\" === typeof FinalizationRegistry) return yb = a => a, b;\n              mb = new FinalizationRegistry(a => {\n                nb(a.U);\n              });\n\n              yb = a => {\n                var c = a.U;\n                c.aa && mb.register(a, {\n                  U: c\n                }, a);\n                return a;\n              };\n\n              lb = a => {\n                mb.unregister(a);\n              };\n\n              return yb(b);\n            }\n\n            var zb = {};\n\n            function Ab(b) {\n              for (; b.length;) {\n                var a = b.pop();\n                b.pop()(a);\n              }\n            }\n\n            function Bb(b) {\n              return this.fromWireType(Da[b >> 2]);\n            }\n\n            var Cb = {},\n                Db = {};\n\n            function W(b, a, c) {\n              function d(g) {\n                g = c(g);\n                g.length !== b.length && wb(\"Mismatched type converter count\");\n\n                for (var l = 0; l < b.length; ++l) Y(b[l], g[l]);\n              }\n\n              b.forEach(function (g) {\n                Db[g] = a;\n              });\n              var e = Array(a.length),\n                  f = [],\n                  h = 0;\n              a.forEach((g, l) => {\n                gb.hasOwnProperty(g) ? e[l] = gb[g] : (f.push(g), Cb.hasOwnProperty(g) || (Cb[g] = []), Cb[g].push(() => {\n                  e[l] = gb[g];\n                  ++h;\n                  h === f.length && d(e);\n                }));\n              });\n              0 === f.length && d(e);\n            }\n\n            function Eb(b) {\n              switch (b) {\n                case 1:\n                  return 0;\n\n                case 2:\n                  return 1;\n\n                case 4:\n                  return 2;\n\n                case 8:\n                  return 3;\n\n                default:\n                  throw new TypeError(\"Unknown type size: \" + b);\n              }\n            }\n\n            function Y(b, a) {\n              let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n              if (!(\"argPackAdvance\" in a)) throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n              var d = a.name;\n              b || Q('type \"' + d + '\" must have a positive integer typeid pointer');\n\n              if (gb.hasOwnProperty(b)) {\n                if (c.lb) return;\n                Q(\"Cannot register type '\" + d + \"' twice\");\n              }\n\n              gb[b] = a;\n              delete Db[b];\n              Cb.hasOwnProperty(b) && (a = Cb[b], delete Cb[b], a.forEach(e => e()));\n            }\n\n            function Fb(b) {\n              Q(b.U.X.V.name + \" instance already deleted\");\n            }\n\n            function Gb() {}\n\n            function Hb(b, a, c) {\n              if (void 0 === b[a].Y) {\n                var d = b[a];\n\n                b[a] = function () {\n                  b[a].Y.hasOwnProperty(arguments.length) || Q(\"Function '\" + c + \"' called with an invalid number of arguments (\" + arguments.length + \") - expects one of (\" + b[a].Y + \")!\");\n                  return b[a].Y[arguments.length].apply(this, arguments);\n                };\n\n                b[a].Y = [];\n                b[a].Y[d.ja] = d;\n              }\n            }\n\n            function Ib(b, a, c) {\n              m.hasOwnProperty(b) ? ((void 0 === c || void 0 !== m[b].Y && void 0 !== m[b].Y[c]) && Q(\"Cannot register public name '\" + b + \"' twice\"), Hb(m, b, b), m.hasOwnProperty(c) && Q(\"Cannot register multiple overloads of a function with the same number of arguments (\" + c + \")!\"), m[b].Y[c] = a) : (m[b] = a, void 0 !== c && (m[b].zb = c));\n            }\n\n            function Jb(b, a, c, d, e, f, h, g) {\n              this.name = b;\n              this.constructor = a;\n              this.ea = c;\n              this.ha = d;\n              this.$ = e;\n              this.gb = f;\n              this.na = h;\n              this.ab = g;\n              this.Ma = [];\n            }\n\n            function Kb(b, a, c) {\n              for (; a !== c;) a.na || Q(\"Expected null or instance of \" + c.name + \", got an instance of \" + a.name), b = a.na(b), a = a.$;\n\n              return b;\n            }\n\n            function Lb(b, a) {\n              if (null === a) return this.wa && Q(\"null is not a valid \" + this.name), 0;\n              a.U || Q('Cannot pass \"' + Mb(a) + '\" as a ' + this.name);\n              a.U.W || Q(\"Cannot pass deleted object as a pointer of type \" + this.name);\n              return Kb(a.U.W, a.U.X.V, this.V);\n            }\n\n            function Nb(b, a) {\n              if (null === a) {\n                this.wa && Q(\"null is not a valid \" + this.name);\n\n                if (this.qa) {\n                  var c = this.xa();\n                  null !== b && b.push(this.ha, c);\n                  return c;\n                }\n\n                return 0;\n              }\n\n              a.U || Q('Cannot pass \"' + Mb(a) + '\" as a ' + this.name);\n              a.U.W || Q(\"Cannot pass deleted object as a pointer of type \" + this.name);\n              !this.pa && a.U.X.pa && Q(\"Cannot convert argument of type \" + (a.U.ca ? a.U.ca.name : a.U.X.name) + \" to parameter type \" + this.name);\n              c = Kb(a.U.W, a.U.X.V, this.V);\n              if (this.qa) switch (void 0 === a.U.aa && Q(\"Passing raw pointer to smart pointer is illegal\"), this.xb) {\n                case 0:\n                  a.U.ca === this ? c = a.U.aa : Q(\"Cannot convert argument of type \" + (a.U.ca ? a.U.ca.name : a.U.X.name) + \" to parameter type \" + this.name);\n                  break;\n\n                case 1:\n                  c = a.U.aa;\n                  break;\n\n                case 2:\n                  if (a.U.ca === this) c = a.U.aa;else {\n                    var d = a.clone();\n                    c = this.tb(c, S(function () {\n                      d[\"delete\"]();\n                    }));\n                    null !== b && b.push(this.ha, c);\n                  }\n                  break;\n\n                default:\n                  Q(\"Unsupporting sharing policy\");\n              }\n              return c;\n            }\n\n            function Ob(b, a) {\n              if (null === a) return this.wa && Q(\"null is not a valid \" + this.name), 0;\n              a.U || Q('Cannot pass \"' + Mb(a) + '\" as a ' + this.name);\n              a.U.W || Q(\"Cannot pass deleted object as a pointer of type \" + this.name);\n              a.U.X.pa && Q(\"Cannot convert argument of type \" + a.U.X.name + \" to parameter type \" + this.name);\n              return Kb(a.U.W, a.U.X.V, this.V);\n            }\n\n            function Pb(b, a, c, d) {\n              this.name = b;\n              this.V = a;\n              this.wa = c;\n              this.pa = d;\n              this.qa = !1;\n              this.ha = this.tb = this.xa = this.Na = this.xb = this.sb = void 0;\n              void 0 !== a.$ ? this.toWireType = Nb : (this.toWireType = d ? Lb : Ob, this.ba = null);\n            }\n\n            function Qb(b, a, c) {\n              m.hasOwnProperty(b) || wb(\"Replacing nonexistant public symbol\");\n              void 0 !== m[b].Y && void 0 !== c ? m[b].Y[c] = a : (m[b] = a, m[b].ja = c);\n            }\n\n            function Rb(b, a) {\n              var c = [];\n              return function () {\n                c.length = 0;\n                Object.assign(c, arguments);\n\n                if (b.includes(\"j\")) {\n                  var d = m[\"dynCall_\" + b];\n                  d = c && c.length ? d.apply(null, [a].concat(c)) : d.call(null, a);\n                } else d = Ha.get(a).apply(null, c);\n\n                return d;\n              };\n            }\n\n            function Z(b, a) {\n              b = T(b);\n              var c = b.includes(\"j\") ? Rb(b, a) : Ha.get(a);\n              \"function\" != typeof c && Q(\"unknown function pointer with signature \" + b + \": \" + a);\n              return c;\n            }\n\n            var Sb = void 0;\n\n            function Tb(b, a) {\n              function c(f) {\n                e[f] || gb[f] || (Db[f] ? Db[f].forEach(c) : (d.push(f), e[f] = !0));\n              }\n\n              var d = [],\n                  e = {};\n              a.forEach(c);\n              throw new Sb(b + \": \" + d.map(hb).join([\", \"]));\n            }\n\n            function Ub(b, a, c, d, e) {\n              var f = a.length;\n              2 > f && Q(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n              var h = null !== a[1] && null !== c,\n                  g = !1;\n\n              for (c = 1; c < a.length; ++c) if (null !== a[c] && void 0 === a[c].ba) {\n                g = !0;\n                break;\n              }\n\n              var l = \"void\" !== a[0].name,\n                  k = f - 2,\n                  p = Array(k),\n                  r = [],\n                  t = [];\n              return function () {\n                arguments.length !== k && Q(\"function \" + b + \" called with \" + arguments.length + \" arguments, expected \" + k + \" args!\");\n                t.length = 0;\n                r.length = h ? 2 : 1;\n                r[0] = e;\n\n                if (h) {\n                  var v = a[1].toWireType(t, this);\n                  r[1] = v;\n                }\n\n                for (var q = 0; q < k; ++q) p[q] = a[q + 2].toWireType(t, arguments[q]), r.push(p[q]);\n\n                q = d.apply(null, r);\n                if (g) Ab(t);else for (var E = h ? 1 : 2; E < a.length; E++) {\n                  var I = 1 === E ? v : p[E - 2];\n                  null !== a[E].ba && a[E].ba(I);\n                }\n                v = l ? a[0].fromWireType(q) : void 0;\n                return v;\n              };\n            }\n\n            function Vb(b, a) {\n              for (var c = [], d = 0; d < b; d++) c.push(M[a + 4 * d >> 2]);\n\n              return c;\n            }\n\n            function Wb(b, a, c) {\n              b instanceof Object || Q(c + ' with invalid \"this\": ' + b);\n              b instanceof a.V.constructor || Q(c + ' incompatible with \"this\" of type ' + b.constructor.name);\n              b.U.W || Q(\"cannot call emscripten binding method \" + c + \" on deleted object\");\n              return Kb(b.U.W, b.U.X.V, a.V);\n            }\n\n            function Xb(b) {\n              4 < b && 0 === --O[b].ya && (O[b] = void 0, Wa.push(b));\n            }\n\n            function Zb(b, a, c) {\n              switch (a) {\n                case 0:\n                  return function (d) {\n                    return this.fromWireType((c ? Aa : H)[d]);\n                  };\n\n                case 1:\n                  return function (d) {\n                    return this.fromWireType((c ? Ba : Ca)[d >> 1]);\n                  };\n\n                case 2:\n                  return function (d) {\n                    return this.fromWireType((c ? Da : M)[d >> 2]);\n                  };\n\n                default:\n                  throw new TypeError(\"Unknown integer type: \" + b);\n              }\n            }\n\n            function Mb(b) {\n              if (null === b) return \"null\";\n              var a = typeof b;\n              return \"object\" === a || \"array\" === a || \"function\" === a ? b.toString() : \"\" + b;\n            }\n\n            function $b(b, a) {\n              switch (a) {\n                case 2:\n                  return function (c) {\n                    return this.fromWireType(Ea[c >> 2]);\n                  };\n\n                case 3:\n                  return function (c) {\n                    return this.fromWireType(Fa[c >> 3]);\n                  };\n\n                default:\n                  throw new TypeError(\"Unknown float type: \" + b);\n              }\n            }\n\n            function ac(b, a, c) {\n              switch (a) {\n                case 0:\n                  return c ? function (d) {\n                    return Aa[d];\n                  } : function (d) {\n                    return H[d];\n                  };\n\n                case 1:\n                  return c ? function (d) {\n                    return Ba[d >> 1];\n                  } : function (d) {\n                    return Ca[d >> 1];\n                  };\n\n                case 2:\n                  return c ? function (d) {\n                    return Da[d >> 2];\n                  } : function (d) {\n                    return M[d >> 2];\n                  };\n\n                default:\n                  throw new TypeError(\"Unknown integer type: \" + b);\n              }\n            }\n\n            var bc = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf-16le\") : void 0;\n\n            function cc(b, a) {\n              var c = b >> 1;\n\n              for (var d = c + a / 2; !(c >= d) && Ca[c];) ++c;\n\n              c <<= 1;\n              if (32 < c - b && bc) return bc.decode(H.subarray(b, c));\n              c = \"\";\n\n              for (d = 0; !(d >= a / 2); ++d) {\n                var e = Ba[b + 2 * d >> 1];\n                if (0 == e) break;\n                c += String.fromCharCode(e);\n              }\n\n              return c;\n            }\n\n            function dc(b, a, c) {\n              void 0 === c && (c = 2147483647);\n              if (2 > c) return 0;\n              c -= 2;\n              var d = a;\n              c = c < 2 * b.length ? c / 2 : b.length;\n\n              for (var e = 0; e < c; ++e) Ba[a >> 1] = b.charCodeAt(e), a += 2;\n\n              Ba[a >> 1] = 0;\n              return a - d;\n            }\n\n            function ec(b) {\n              return 2 * b.length;\n            }\n\n            function fc(b, a) {\n              for (var c = 0, d = \"\"; !(c >= a / 4);) {\n                var e = Da[b + 4 * c >> 2];\n                if (0 == e) break;\n                ++c;\n                65536 <= e ? (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023)) : d += String.fromCharCode(e);\n              }\n\n              return d;\n            }\n\n            function gc(b, a, c) {\n              void 0 === c && (c = 2147483647);\n              if (4 > c) return 0;\n              var d = a;\n              c = d + c - 4;\n\n              for (var e = 0; e < b.length; ++e) {\n                var f = b.charCodeAt(e);\n\n                if (55296 <= f && 57343 >= f) {\n                  var h = b.charCodeAt(++e);\n                  f = 65536 + ((f & 1023) << 10) | h & 1023;\n                }\n\n                Da[a >> 2] = f;\n                a += 4;\n                if (a + 4 > c) break;\n              }\n\n              Da[a >> 2] = 0;\n              return a - d;\n            }\n\n            function hc(b) {\n              for (var a = 0, c = 0; c < b.length; ++c) {\n                var d = b.charCodeAt(c);\n                55296 <= d && 57343 >= d && ++c;\n                a += 4;\n              }\n\n              return a;\n            }\n\n            var ic = {};\n\n            function jc(b) {\n              var a = ic[b];\n              return void 0 === a ? T(b) : a;\n            }\n\n            var kc = [];\n\n            function lc(b) {\n              var a = kc.length;\n              kc.push(b);\n              return a;\n            }\n\n            function mc(b, a) {\n              for (var c = Array(b), d = 0; d < b; ++d) c[d] = kb(M[a + 4 * d >> 2], \"parameter \" + d);\n\n              return c;\n            }\n\n            var nc = [],\n                oc = [null, [], []];\n            Za = m.BindingError = Ya(\"BindingError\");\n\n            m.count_emval_handles = function () {\n              for (var b = 0, a = 5; a < O.length; ++a) void 0 !== O[a] && ++b;\n\n              return b;\n            };\n\n            m.get_first_emval = function () {\n              for (var b = 5; b < O.length; ++b) if (void 0 !== O[b]) return O[b];\n\n              return null;\n            };\n\n            ab = m.PureVirtualError = Ya(\"PureVirtualError\");\n\n            for (var pc = Array(256), qc = 0; 256 > qc; ++qc) pc[qc] = String.fromCharCode(qc);\n\n            bb = pc;\n\n            m.getInheritedInstanceCount = function () {\n              return Object.keys(V).length;\n            };\n\n            m.getLiveInheritedInstances = function () {\n              var b = [],\n                  a;\n\n              for (a in V) V.hasOwnProperty(a) && b.push(V[a]);\n\n              return b;\n            };\n\n            m.flushPendingDeletes = db;\n\n            m.setDelayFunction = function (b) {\n              eb = b;\n              cb.length && eb && eb(db);\n            };\n\n            vb = m.InternalError = Ya(\"InternalError\");\n\n            Gb.prototype.isAliasOf = function (b) {\n              if (!(this instanceof Gb && b instanceof Gb)) return !1;\n              var a = this.U.X.V,\n                  c = this.U.W,\n                  d = b.U.X.V;\n\n              for (b = b.U.W; a.$;) c = a.na(c), a = a.$;\n\n              for (; d.$;) b = d.na(b), d = d.$;\n\n              return a === d && c === b;\n            };\n\n            Gb.prototype.clone = function () {\n              this.U.W || Fb(this);\n              if (this.U.ma) return this.U.count.value += 1, this;\n              var b = yb,\n                  a = Object,\n                  c = a.create,\n                  d = Object.getPrototypeOf(this),\n                  e = this.U;\n              b = b(c.call(a, d, {\n                U: {\n                  value: {\n                    count: e.count,\n                    ka: e.ka,\n                    ma: e.ma,\n                    W: e.W,\n                    X: e.X,\n                    aa: e.aa,\n                    ca: e.ca\n                  }\n                }\n              }));\n              b.U.count.value += 1;\n              b.U.ka = !1;\n              return b;\n            };\n\n            Gb.prototype[\"delete\"] = function () {\n              this.U.W || Fb(this);\n              this.U.ka && !this.U.ma && Q(\"Object already scheduled for deletion\");\n              lb(this);\n              nb(this.U);\n              this.U.ma || (this.U.aa = void 0, this.U.W = void 0);\n            };\n\n            Gb.prototype.isDeleted = function () {\n              return !this.U.W;\n            };\n\n            Gb.prototype.deleteLater = function () {\n              this.U.W || Fb(this);\n              this.U.ka && !this.U.ma && Q(\"Object already scheduled for deletion\");\n              cb.push(this);\n              1 === cb.length && eb && eb(db);\n              this.U.ka = !0;\n              return this;\n            };\n\n            Pb.prototype.hb = function (b) {\n              this.Na && (b = this.Na(b));\n              return b;\n            };\n\n            Pb.prototype.Ga = function (b) {\n              this.ha && this.ha(b);\n            };\n\n            Pb.prototype.argPackAdvance = 8;\n            Pb.prototype.readValueFromPointer = Bb;\n\n            Pb.prototype.deleteObject = function (b) {\n              if (null !== b) b[\"delete\"]();\n            };\n\n            Pb.prototype.fromWireType = function (b) {\n              function a() {\n                return this.qa ? xb(this.V.ea, {\n                  X: this.sb,\n                  W: c,\n                  ca: this,\n                  aa: b\n                }) : xb(this.V.ea, {\n                  X: this,\n                  W: b\n                });\n              }\n\n              var c = this.hb(b);\n              if (!c) return this.Ga(b), null;\n              var d = ub(this.V, c);\n\n              if (void 0 !== d) {\n                if (0 === d.U.count.value) return d.U.W = c, d.U.aa = b, d.clone();\n                d = d.clone();\n                this.Ga(b);\n                return d;\n              }\n\n              d = this.V.gb(c);\n              d = tb[d];\n              if (!d) return a.call(this);\n              d = this.pa ? d.Xa : d.pointerType;\n              var e = ob(c, this.V, d.V);\n              return null === e ? a.call(this) : this.qa ? xb(d.V.ea, {\n                X: d,\n                W: e,\n                ca: this,\n                aa: b\n              }) : xb(d.V.ea, {\n                X: d,\n                W: e\n              });\n            };\n\n            Sb = m.UnboundTypeError = Ya(\"UnboundTypeError\");\n            var sc = {\n              l: function (b, a, c) {\n                b = T(b);\n                a = kb(a, \"wrapper\");\n                c = $a(c);\n                var d = [].slice,\n                    e = a.V,\n                    f = e.ea,\n                    h = e.$.ea,\n                    g = e.$.constructor;\n                b = Va(b, function () {\n                  e.$.Ma.forEach(function (k) {\n                    if (this[k] === h[k]) throw new ab(\"Pure virtual function \" + k + \" must be implemented in JavaScript\");\n                  }.bind(this));\n                  Object.defineProperty(this, \"__parent\", {\n                    value: f\n                  });\n\n                  this.__construct.apply(this, d.call(arguments));\n                });\n\n                f.__construct = function () {\n                  this === f && Q(\"Pass correct 'this' to __construct\");\n                  var k = g.implement.apply(void 0, [this].concat(d.call(arguments)));\n                  lb(k);\n                  var p = k.U;\n                  k.notifyOnDestruction();\n                  p.ma = !0;\n                  Object.defineProperties(this, {\n                    U: {\n                      value: p\n                    }\n                  });\n                  yb(this);\n                  k = p.W;\n                  k = fb(e, k);\n                  V.hasOwnProperty(k) ? Q(\"Tried to register registered instance: \" + k) : V[k] = this;\n                };\n\n                f.__destruct = function () {\n                  this === f && Q(\"Pass correct 'this' to __destruct\");\n                  lb(this);\n                  var k = this.U.W;\n                  k = fb(e, k);\n                  V.hasOwnProperty(k) ? delete V[k] : Q(\"Tried to unregister unregistered instance: \" + k);\n                };\n\n                b.prototype = Object.create(f);\n\n                for (var l in c) b.prototype[l] = c[l];\n\n                return S(b);\n              },\n              I: function (b) {\n                var a = zb[b];\n                delete zb[b];\n                var c = a.xa,\n                    d = a.ha,\n                    e = a.Ja,\n                    f = e.map(h => h.kb).concat(e.map(h => h.vb));\n                W([b], f, h => {\n                  var g = {};\n                  e.forEach((l, k) => {\n                    var p = h[k],\n                        r = l.ib,\n                        t = l.jb,\n                        v = h[k + e.length],\n                        q = l.ub,\n                        E = l.wb;\n                    g[l.eb] = {\n                      read: I => p.fromWireType(r(t, I)),\n                      write: (I, w) => {\n                        var z = [];\n                        q(E, I, v.toWireType(z, w));\n                        Ab(z);\n                      }\n                    };\n                  });\n                  return [{\n                    name: a.name,\n                    fromWireType: function (l) {\n                      var k = {},\n                          p;\n\n                      for (p in g) k[p] = g[p].read(l);\n\n                      d(l);\n                      return k;\n                    },\n                    toWireType: function (l, k) {\n                      for (var p in g) if (!(p in k)) throw new TypeError('Missing field:  \"' + p + '\"');\n\n                      var r = c();\n\n                      for (p in g) g[p].write(r, k[p]);\n\n                      null !== l && l.push(d, r);\n                      return r;\n                    },\n                    argPackAdvance: 8,\n                    readValueFromPointer: Bb,\n                    ba: d\n                  }];\n                });\n              },\n              x: function () {},\n              B: function (b, a, c, d, e) {\n                var f = Eb(c);\n                a = T(a);\n                Y(b, {\n                  name: a,\n                  fromWireType: function (h) {\n                    return !!h;\n                  },\n                  toWireType: function (h, g) {\n                    return g ? d : e;\n                  },\n                  argPackAdvance: 8,\n                  readValueFromPointer: function (h) {\n                    if (1 === c) var g = Aa;else if (2 === c) g = Ba;else if (4 === c) g = Da;else throw new TypeError(\"Unknown boolean type size: \" + a);\n                    return this.fromWireType(g[h >> f]);\n                  },\n                  ba: null\n                });\n              },\n              c: function (b, a, c, d, e, f, h, g, l, k, p, r, t) {\n                p = T(p);\n                f = Z(e, f);\n                g && (g = Z(h, g));\n                k && (k = Z(l, k));\n                t = Z(r, t);\n                var v = Ua(p);\n                Ib(v, function () {\n                  Tb(\"Cannot construct \" + p + \" due to unbound types\", [d]);\n                });\n                W([b, a, c], d ? [d] : [], function (q) {\n                  q = q[0];\n\n                  if (d) {\n                    var E = q.V;\n                    var I = E.ea;\n                  } else I = Gb.prototype;\n\n                  q = Va(v, function () {\n                    if (Object.getPrototypeOf(this) !== w) throw new Za(\"Use 'new' to construct \" + p);\n                    if (void 0 === z.ia) throw new Za(p + \" has no accessible constructor\");\n                    var P = z.ia[arguments.length];\n                    if (void 0 === P) throw new Za(\"Tried to invoke ctor of \" + p + \" with invalid number of parameters (\" + arguments.length + \") - expected (\" + Object.keys(z.ia).toString() + \") parameters instead!\");\n                    return P.apply(this, arguments);\n                  });\n                  var w = Object.create(I, {\n                    constructor: {\n                      value: q\n                    }\n                  });\n                  q.prototype = w;\n                  var z = new Jb(p, q, w, t, E, f, g, k);\n                  E = new Pb(p, z, !0, !1);\n                  I = new Pb(p + \"*\", z, !1, !1);\n                  var J = new Pb(p + \" const*\", z, !1, !0);\n                  tb[b] = {\n                    pointerType: I,\n                    Xa: J\n                  };\n                  Qb(v, q);\n                  return [E, I, J];\n                });\n              },\n              h: function (b, a, c, d, e, f, h) {\n                var g = Vb(c, d);\n                a = T(a);\n                f = Z(e, f);\n                W([], [b], function (l) {\n                  function k() {\n                    Tb(\"Cannot call \" + p + \" due to unbound types\", g);\n                  }\n\n                  l = l[0];\n                  var p = l.name + \".\" + a;\n                  a.startsWith(\"@@\") && (a = Symbol[a.substring(2)]);\n                  var r = l.V.constructor;\n                  void 0 === r[a] ? (k.ja = c - 1, r[a] = k) : (Hb(r, a, p), r[a].Y[c - 1] = k);\n                  W([], g, function (t) {\n                    t = Ub(p, [t[0], null].concat(t.slice(1)), null, f, h);\n                    void 0 === r[a].Y ? (t.ja = c - 1, r[a] = t) : r[a].Y[c - 1] = t;\n                    return [];\n                  });\n                  return [];\n                });\n              },\n              n: function (b, a, c, d, e, f, h, g) {\n                a = T(a);\n                f = Z(e, f);\n                W([], [b], function (l) {\n                  l = l[0];\n                  var k = l.name + \".\" + a,\n                      p = {\n                    get: function () {\n                      Tb(\"Cannot access \" + k + \" due to unbound types\", [c]);\n                    },\n                    enumerable: !0,\n                    configurable: !0\n                  };\n                  p.set = g ? () => {\n                    Tb(\"Cannot access \" + k + \" due to unbound types\", [c]);\n                  } : () => {\n                    Q(k + \" is a read-only property\");\n                  };\n                  Object.defineProperty(l.V.constructor, a, p);\n                  W([], [c], function (r) {\n                    r = r[0];\n                    var t = {\n                      get: function () {\n                        return r.fromWireType(f(d));\n                      },\n                      enumerable: !0\n                    };\n                    g && (g = Z(h, g), t.set = v => {\n                      var q = [];\n                      g(d, r.toWireType(q, v));\n                      Ab(q);\n                    });\n                    Object.defineProperty(l.V.constructor, a, t);\n                    return [];\n                  });\n                  return [];\n                });\n              },\n              k: function (b, a, c, d, e, f) {\n                0 < a || ua();\n                var h = Vb(a, c);\n                e = Z(d, e);\n                W([], [b], function (g) {\n                  g = g[0];\n                  var l = \"constructor \" + g.name;\n                  void 0 === g.V.ia && (g.V.ia = []);\n                  if (void 0 !== g.V.ia[a - 1]) throw new Za(\"Cannot register multiple constructors with identical number of parameters (\" + (a - 1) + \") for class '\" + g.name + \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\");\n\n                  g.V.ia[a - 1] = () => {\n                    Tb(\"Cannot construct \" + g.name + \" due to unbound types\", h);\n                  };\n\n                  W([], h, function (k) {\n                    k.splice(1, 0, null);\n                    g.V.ia[a - 1] = Ub(l, k, null, e, f);\n                    return [];\n                  });\n                  return [];\n                });\n              },\n              a: function (b, a, c, d, e, f, h, g) {\n                var l = Vb(c, d);\n                a = T(a);\n                f = Z(e, f);\n                W([], [b], function (k) {\n                  function p() {\n                    Tb(\"Cannot call \" + r + \" due to unbound types\", l);\n                  }\n\n                  k = k[0];\n                  var r = k.name + \".\" + a;\n                  a.startsWith(\"@@\") && (a = Symbol[a.substring(2)]);\n                  g && k.V.Ma.push(a);\n                  var t = k.V.ea,\n                      v = t[a];\n                  void 0 === v || void 0 === v.Y && v.className !== k.name && v.ja === c - 2 ? (p.ja = c - 2, p.className = k.name, t[a] = p) : (Hb(t, a, r), t[a].Y[c - 2] = p);\n                  W([], l, function (q) {\n                    q = Ub(r, q, k, f, h);\n                    void 0 === t[a].Y ? (q.ja = c - 2, t[a] = q) : t[a].Y[c - 2] = q;\n                    return [];\n                  });\n                  return [];\n                });\n              },\n              b: function (b, a, c, d, e, f, h, g, l, k) {\n                a = T(a);\n                e = Z(d, e);\n                W([], [b], function (p) {\n                  p = p[0];\n                  var r = p.name + \".\" + a,\n                      t = {\n                    get: function () {\n                      Tb(\"Cannot access \" + r + \" due to unbound types\", [c, h]);\n                    },\n                    enumerable: !0,\n                    configurable: !0\n                  };\n                  t.set = l ? () => {\n                    Tb(\"Cannot access \" + r + \" due to unbound types\", [c, h]);\n                  } : () => {\n                    Q(r + \" is a read-only property\");\n                  };\n                  Object.defineProperty(p.V.ea, a, t);\n                  W([], l ? [c, h] : [c], function (v) {\n                    var q = v[0],\n                        E = {\n                      get: function () {\n                        var w = Wb(this, p, r + \" getter\");\n                        return q.fromWireType(e(f, w));\n                      },\n                      enumerable: !0\n                    };\n\n                    if (l) {\n                      l = Z(g, l);\n                      var I = v[1];\n\n                      E.set = function (w) {\n                        var z = Wb(this, p, r + \" setter\"),\n                            J = [];\n                        l(k, z, I.toWireType(J, w));\n                        Ab(J);\n                      };\n                    }\n\n                    Object.defineProperty(p.V.ea, a, E);\n                    return [];\n                  });\n                  return [];\n                });\n              },\n              A: function (b, a) {\n                a = T(a);\n                Y(b, {\n                  name: a,\n                  fromWireType: function (c) {\n                    var d = $a(c);\n                    Xb(c);\n                    return d;\n                  },\n                  toWireType: function (c, d) {\n                    return S(d);\n                  },\n                  argPackAdvance: 8,\n                  readValueFromPointer: Bb,\n                  ba: null\n                });\n              },\n              j: function (b, a, c, d) {\n                function e() {}\n\n                c = Eb(c);\n                a = T(a);\n                e.values = {};\n                Y(b, {\n                  name: a,\n                  constructor: e,\n                  fromWireType: function (f) {\n                    return this.constructor.values[f];\n                  },\n                  toWireType: function (f, h) {\n                    return h.value;\n                  },\n                  argPackAdvance: 8,\n                  readValueFromPointer: Zb(a, c, d),\n                  ba: null\n                });\n                Ib(a, e);\n              },\n              i: function (b, a, c) {\n                var d = kb(b, \"enum\");\n                a = T(a);\n                b = d.constructor;\n                d = Object.create(d.constructor.prototype, {\n                  value: {\n                    value: c\n                  },\n                  constructor: {\n                    value: Va(d.name + \"_\" + a, function () {})\n                  }\n                });\n                b.values[c] = d;\n                b[a] = d;\n              },\n              r: function (b, a, c) {\n                c = Eb(c);\n                a = T(a);\n                Y(b, {\n                  name: a,\n                  fromWireType: function (d) {\n                    return d;\n                  },\n                  toWireType: function (d, e) {\n                    return e;\n                  },\n                  argPackAdvance: 8,\n                  readValueFromPointer: $b(a, c),\n                  ba: null\n                });\n              },\n              q: function (b, a, c, d, e, f) {\n                var h = Vb(a, c);\n                b = T(b);\n                e = Z(d, e);\n                Ib(b, function () {\n                  Tb(\"Cannot call \" + b + \" due to unbound types\", h);\n                }, a - 1);\n                W([], h, function (g) {\n                  Qb(b, Ub(b, [g[0], null].concat(g.slice(1)), null, e, f), a - 1);\n                  return [];\n                });\n              },\n              g: function (b, a, c, d, e) {\n                a = T(a);\n                -1 === e && (e = 4294967295);\n                e = Eb(c);\n\n                var f = g => g;\n\n                if (0 === d) {\n                  var h = 32 - 8 * c;\n\n                  f = g => g << h >>> h;\n                }\n\n                c = a.includes(\"unsigned\") ? function (g, l) {\n                  return l >>> 0;\n                } : function (g, l) {\n                  return l;\n                };\n                Y(b, {\n                  name: a,\n                  fromWireType: f,\n                  toWireType: c,\n                  argPackAdvance: 8,\n                  readValueFromPointer: ac(a, e, 0 !== d),\n                  ba: null\n                });\n              },\n              d: function (b, a, c) {\n                function d(f) {\n                  f >>= 2;\n                  var h = M;\n                  return new e(za, h[f + 1], h[f]);\n                }\n\n                var e = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][a];\n                c = T(c);\n                Y(b, {\n                  name: c,\n                  fromWireType: d,\n                  argPackAdvance: 8,\n                  readValueFromPointer: d\n                }, {\n                  lb: !0\n                });\n              },\n              s: function (b, a) {\n                a = T(a);\n                var c = \"std::string\" === a;\n                Y(b, {\n                  name: a,\n                  fromWireType: function (d) {\n                    var e = M[d >> 2],\n                        f = d + 4;\n                    if (c) for (var h = f, g = 0; g <= e; ++g) {\n                      var l = f + g;\n\n                      if (g == e || 0 == H[l]) {\n                        h = h ? ya(H, h, l - h) : \"\";\n                        if (void 0 === k) var k = h;else k += String.fromCharCode(0), k += h;\n                        h = l + 1;\n                      }\n                    } else {\n                      k = Array(e);\n\n                      for (g = 0; g < e; ++g) k[g] = String.fromCharCode(H[f + g]);\n\n                      k = k.join(\"\");\n                    }\n                    jb(d);\n                    return k;\n                  },\n                  toWireType: function (d, e) {\n                    e instanceof ArrayBuffer && (e = new Uint8Array(e));\n                    var f,\n                        h = \"string\" == typeof e;\n                    h || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int8Array || Q(\"Cannot pass non-string to std::string\");\n                    var g;\n                    if (c && h) for (f = g = 0; f < e.length; ++f) {\n                      var l = e.charCodeAt(f);\n                      127 >= l ? g++ : 2047 >= l ? g += 2 : 55296 <= l && 57343 >= l ? (g += 4, ++f) : g += 3;\n                    } else g = e.length;\n                    f = g;\n                    g = rc(4 + f + 1);\n                    l = g + 4;\n                    M[g >> 2] = f;\n\n                    if (c && h) {\n                      if (h = l, l = f + 1, f = H, 0 < l) {\n                        l = h + l - 1;\n\n                        for (var k = 0; k < e.length; ++k) {\n                          var p = e.charCodeAt(k);\n\n                          if (55296 <= p && 57343 >= p) {\n                            var r = e.charCodeAt(++k);\n                            p = 65536 + ((p & 1023) << 10) | r & 1023;\n                          }\n\n                          if (127 >= p) {\n                            if (h >= l) break;\n                            f[h++] = p;\n                          } else {\n                            if (2047 >= p) {\n                              if (h + 1 >= l) break;\n                              f[h++] = 192 | p >> 6;\n                            } else {\n                              if (65535 >= p) {\n                                if (h + 2 >= l) break;\n                                f[h++] = 224 | p >> 12;\n                              } else {\n                                if (h + 3 >= l) break;\n                                f[h++] = 240 | p >> 18;\n                                f[h++] = 128 | p >> 12 & 63;\n                              }\n\n                              f[h++] = 128 | p >> 6 & 63;\n                            }\n\n                            f[h++] = 128 | p & 63;\n                          }\n                        }\n\n                        f[h] = 0;\n                      }\n                    } else if (h) for (h = 0; h < f; ++h) k = e.charCodeAt(h), 255 < k && (jb(l), Q(\"String has UTF-16 code units that do not fit in 8 bits\")), H[l + h] = k;else for (h = 0; h < f; ++h) H[l + h] = e[h];\n\n                    null !== d && d.push(jb, g);\n                    return g;\n                  },\n                  argPackAdvance: 8,\n                  readValueFromPointer: Bb,\n                  ba: function (d) {\n                    jb(d);\n                  }\n                });\n              },\n              p: function (b, a, c) {\n                c = T(c);\n\n                if (2 === a) {\n                  var d = cc;\n                  var e = dc;\n                  var f = ec;\n\n                  var h = () => Ca;\n\n                  var g = 1;\n                } else 4 === a && (d = fc, e = gc, f = hc, h = () => M, g = 2);\n\n                Y(b, {\n                  name: c,\n                  fromWireType: function (l) {\n                    for (var k = M[l >> 2], p = h(), r, t = l + 4, v = 0; v <= k; ++v) {\n                      var q = l + 4 + v * a;\n                      if (v == k || 0 == p[q >> g]) t = d(t, q - t), void 0 === r ? r = t : (r += String.fromCharCode(0), r += t), t = q + a;\n                    }\n\n                    jb(l);\n                    return r;\n                  },\n                  toWireType: function (l, k) {\n                    \"string\" != typeof k && Q(\"Cannot pass non-string to C++ string type \" + c);\n                    var p = f(k),\n                        r = rc(4 + p + a);\n                    M[r >> 2] = p >> g;\n                    e(k, r + 4, p + a);\n                    null !== l && l.push(jb, r);\n                    return r;\n                  },\n                  argPackAdvance: 8,\n                  readValueFromPointer: Bb,\n                  ba: function (l) {\n                    jb(l);\n                  }\n                });\n              },\n              K: function (b, a, c, d, e, f) {\n                zb[b] = {\n                  name: T(a),\n                  xa: Z(c, d),\n                  ha: Z(e, f),\n                  Ja: []\n                };\n              },\n              J: function (b, a, c, d, e, f, h, g, l, k) {\n                zb[b].Ja.push({\n                  eb: T(a),\n                  kb: c,\n                  ib: Z(d, e),\n                  jb: f,\n                  vb: h,\n                  ub: Z(g, l),\n                  wb: k\n                });\n              },\n              C: function (b, a) {\n                a = T(a);\n                Y(b, {\n                  nb: !0,\n                  name: a,\n                  argPackAdvance: 0,\n                  fromWireType: function () {},\n                  toWireType: function () {}\n                });\n              },\n              m: function (b, a, c) {\n                b = $a(b);\n                a = kb(a, \"emval::as\");\n                var d = [],\n                    e = S(d);\n                M[c >> 2] = e;\n                return a.toWireType(d, b);\n              },\n              t: function (b, a, c, d, e) {\n                b = kc[b];\n                a = $a(a);\n                c = jc(c);\n                var f = [];\n                M[d >> 2] = S(f);\n                return b(a, c, f, e);\n              },\n              f: function (b, a, c, d) {\n                b = kc[b];\n                a = $a(a);\n                c = jc(c);\n                b(a, c, null, d);\n              },\n              L: Xb,\n              e: function (b, a) {\n                var c = mc(b, a),\n                    d = c[0];\n                a = d.name + \"_$\" + c.slice(1).map(function (h) {\n                  return h.name;\n                }).join(\"_\") + \"$\";\n                var e = nc[a];\n                if (void 0 !== e) return e;\n                var f = Array(b - 1);\n                e = lc((h, g, l, k) => {\n                  for (var p = 0, r = 0; r < b - 1; ++r) f[r] = c[r + 1].readValueFromPointer(k + p), p += c[r + 1].argPackAdvance;\n\n                  h = h[g].apply(h, f);\n\n                  for (r = 0; r < b - 1; ++r) c[r + 1].Za && c[r + 1].Za(f[r]);\n\n                  if (!d.nb) return d.toWireType(l, h);\n                });\n                return nc[a] = e;\n              },\n              D: function (b) {\n                b = jc(b);\n                return S(m[b]);\n              },\n              H: function (b, a) {\n                b = $a(b);\n                a = $a(a);\n                return S(b[a]);\n              },\n              E: function (b) {\n                4 < b && (O[b].ya += 1);\n              },\n              G: function (b) {\n                return S(jc(b));\n              },\n              F: function (b) {\n                var a = $a(b);\n                Ab(a);\n                Xb(b);\n              },\n              u: function (b, a) {\n                b = kb(b, \"_emval_take_value\");\n                b = b.readValueFromPointer(a);\n                return S(b);\n              },\n              v: function () {\n                ua(\"\");\n              },\n              o: function (b) {\n                var a = H.length;\n                b >>>= 0;\n                if (2147483648 < b) return !1;\n\n                for (var c = 1; 4 >= c; c *= 2) {\n                  var d = a * (1 + .2 / c);\n                  d = Math.min(d, b + 100663296);\n                  var e = Math;\n                  d = Math.max(b, d);\n                  e = e.min.call(e, 2147483648, d + (65536 - d % 65536) % 65536);\n\n                  a: {\n                    try {\n                      va.grow(e - za.byteLength + 65535 >>> 16);\n                      Ga();\n                      var f = 1;\n                      break a;\n                    } catch (h) {}\n\n                    f = void 0;\n                  }\n\n                  if (f) return !0;\n                }\n\n                return !1;\n              },\n              z: function () {\n                return 52;\n              },\n              w: function () {\n                return 70;\n              },\n              y: function (b, a, c, d) {\n                for (var e = 0, f = 0; f < c; f++) {\n                  var h = M[a >> 2],\n                      g = M[a + 4 >> 2];\n                  a += 8;\n\n                  for (var l = 0; l < g; l++) {\n                    var k = H[h + l],\n                        p = oc[b];\n                    0 === k || 10 === k ? ((1 === b ? pa : qa)(ya(p, 0)), p.length = 0) : p.push(k);\n                  }\n\n                  e += g;\n                }\n\n                M[d >> 2] = e;\n                return 0;\n              }\n            };\n\n            (function () {\n              function b(e) {\n                m.asm = e.exports;\n                va = m.asm.M;\n                Ga();\n                Ha = m.asm.S;\n                Ja.unshift(m.asm.N);\n                Ma--;\n                m.monitorRunDependencies && m.monitorRunDependencies(Ma);\n                0 == Ma && (null !== Na && (clearInterval(Na), Na = null), Oa && (e = Oa, Oa = null, e()));\n              }\n\n              function a(e) {\n                b(e.instance);\n              }\n\n              function c(e) {\n                return Sa().then(function (f) {\n                  return WebAssembly.instantiate(f, d);\n                }).then(function (f) {\n                  return f;\n                }).then(e, function (f) {\n                  qa(\"failed to asynchronously prepare wasm: \" + f);\n                  ua(f);\n                });\n              }\n\n              var d = {\n                a: sc\n              };\n              Ma++;\n              m.monitorRunDependencies && m.monitorRunDependencies(Ma);\n              if (m.instantiateWasm) try {\n                return m.instantiateWasm(d, b);\n              } catch (e) {\n                return qa(\"Module.instantiateWasm callback failed with error: \" + e), !1;\n              }\n              (function () {\n                return ra || \"function\" != typeof WebAssembly.instantiateStreaming || Pa() || N.startsWith(\"file://\") || \"function\" != typeof fetch ? c(a) : fetch(N, {\n                  credentials: \"same-origin\"\n                }).then(function (e) {\n                  return WebAssembly.instantiateStreaming(e, d).then(a, function (f) {\n                    qa(\"wasm streaming compile failed: \" + f);\n                    qa(\"falling back to ArrayBuffer instantiation\");\n                    return c(a);\n                  });\n                });\n              })().catch(ba);\n              return {};\n            })();\n\n            m.___wasm_call_ctors = function () {\n              return (m.___wasm_call_ctors = m.asm.N).apply(null, arguments);\n            };\n\n            var jb = m._free = function () {\n              return (jb = m._free = m.asm.O).apply(null, arguments);\n            },\n                rc = m._malloc = function () {\n              return (rc = m._malloc = m.asm.P).apply(null, arguments);\n            },\n                ib = m.___getTypeName = function () {\n              return (ib = m.___getTypeName = m.asm.Q).apply(null, arguments);\n            };\n\n            m.__embind_initialize_bindings = function () {\n              return (m.__embind_initialize_bindings = m.asm.R).apply(null, arguments);\n            };\n\n            m.dynCall_jiji = function () {\n              return (m.dynCall_jiji = m.asm.T).apply(null, arguments);\n            };\n\n            var tc;\n\n            Oa = function uc() {\n              tc || vc();\n              tc || (Oa = uc);\n            };\n\n            function vc() {\n              function b() {\n                if (!tc && (tc = !0, m.calledRun = !0, !wa)) {\n                  Ta(Ja);\n                  aa(m);\n                  if (m.onRuntimeInitialized) m.onRuntimeInitialized();\n                  if (m.postRun) for (\"function\" == typeof m.postRun && (m.postRun = [m.postRun]); m.postRun.length;) {\n                    var a = m.postRun.shift();\n                    Ka.unshift(a);\n                  }\n                  Ta(Ka);\n                }\n              }\n\n              if (!(0 < Ma)) {\n                if (m.preRun) for (\"function\" == typeof m.preRun && (m.preRun = [m.preRun]); m.preRun.length;) La();\n                Ta(Ia);\n                0 < Ma || (m.setStatus ? (m.setStatus(\"Running...\"), setTimeout(function () {\n                  setTimeout(function () {\n                    m.setStatus(\"\");\n                  }, 1);\n                  b();\n                }, 1)) : b());\n              }\n            }\n\n            if (m.preInit) for (\"function\" == typeof m.preInit && (m.preInit = [m.preInit]); 0 < m.preInit.length;) m.preInit.pop()();\n            vc();\n            return Rive.ready;\n          };\n        })();\n        /* harmony default export */\n\n\n        const __WEBPACK_DEFAULT_EXPORT__ = Rive;\n        /***/\n      },\n      /* 2 */\n\n      /***/\n      module => {\n        module.exports = JSON.parse('{\"name\":\"@rive-app/canvas\",\"version\":\"1.0.98\",\"description\":\"Rive\\'s canvas based web api.\",\"main\":\"rive.js\",\"homepage\":\"https://rive.app\",\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/rive-app/rive-wasm/tree/master/js\"},\"keywords\":[\"rive\",\"animation\"],\"author\":\"Rive\",\"contributors\":[\"Luigi Rosso <luigi@rive.app> (https://rive.app)\",\"Maxwell Talbot <max@rive.app> (https://rive.app)\",\"Arthur Vivian <arthur@rive.app> (https://rive.app)\",\"Umberto Sonnino <umberto@rive.app> (https://rive.app)\",\"Matthew Sullivan <matt.j.sullivan@gmail.com> (mailto:matt.j.sullivan@gmail.com)\"],\"license\":\"MIT\",\"files\":[\"rive.js\",\"rive.js.map\",\"rive.wasm\",\"rive.d.ts\",\"rive_advanced.mjs.d.ts\"],\"typings\":\"rive.d.ts\",\"dependencies\":{},\"browser\":{\"fs\":false,\"path\":false}}');\n        /***/\n      },\n      /* 3 */\n\n      /***/\n      (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export */\n\n\n        __webpack_require__.d(__webpack_exports__, {\n          /* harmony export */\n          \"registerTouchInteractions\": () =>\n          /* reexport safe */\n          _registerTouchInteractions__WEBPACK_IMPORTED_MODULE_0__.registerTouchInteractions\n          /* harmony export */\n\n        });\n        /* harmony import */\n\n\n        var _registerTouchInteractions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);\n        /***/\n\n      },\n      /* 4 */\n\n      /***/\n      (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export */\n\n\n        __webpack_require__.d(__webpack_exports__, {\n          /* harmony export */\n          \"registerTouchInteractions\": () =>\n          /* binding */\n          registerTouchInteractions\n          /* harmony export */\n\n        });\n        /**\n         * Registers mouse move/up/down callback handlers on the canvas to send meaningful coordinates to\n         * the state machine pointer move/up/down functions based on cursor interaction\n         */\n\n\n        const registerTouchInteractions = _ref => {\n          let {\n            canvas,\n            artboard,\n            stateMachines = [],\n            renderer,\n            rive,\n            fit,\n            alignment\n          } = _ref;\n\n          if (!canvas || !stateMachines.length || !renderer || !rive || !artboard) {\n            return null;\n          }\n\n          const mouseCallback = event => {\n            const boundingRect = event.currentTarget.getBoundingClientRect();\n            const canvasX = event.clientX - boundingRect.left;\n            const canvasY = event.clientY - boundingRect.top;\n            const forwardMatrix = rive.computeAlignment(fit, alignment, {\n              minX: 0,\n              minY: 0,\n              maxX: boundingRect.width,\n              maxY: boundingRect.height\n            }, artboard.bounds);\n            let invertedMatrix = new rive.Mat2D();\n            forwardMatrix.invert(invertedMatrix);\n            const canvasCoordinatesVector = new rive.Vec2D(canvasX, canvasY);\n            const transformedVector = rive.mapXY(invertedMatrix, canvasCoordinatesVector);\n            const transformedX = transformedVector.x();\n            const transformedY = transformedVector.y();\n            transformedVector.delete();\n            invertedMatrix.delete();\n            canvasCoordinatesVector.delete();\n            forwardMatrix.delete();\n\n            switch (event.type) {\n              // Pointer moving/hovering on the canvas\n              case \"mouseover\":\n              case \"mouseout\":\n              case \"mousemove\":\n                {\n                  for (const stateMachine of stateMachines) {\n                    stateMachine.pointerMove(transformedX, transformedY);\n                  }\n\n                  break;\n                }\n              // Pointer click initiated but not released yet on the canvas\n\n              case \"mousedown\":\n                {\n                  for (const stateMachine of stateMachines) {\n                    stateMachine.pointerDown(transformedX, transformedY);\n                  }\n\n                  break;\n                }\n              // Pointer click released on the canvas\n\n              case \"mouseup\":\n                {\n                  for (const stateMachine of stateMachines) {\n                    stateMachine.pointerUp(transformedX, transformedY);\n                  }\n\n                  break;\n                }\n\n              default:\n            }\n          };\n\n          const callback = mouseCallback.bind(undefined);\n          canvas.addEventListener(\"mouseover\", callback);\n          canvas.addEventListener(\"mouseout\", callback);\n          canvas.addEventListener(\"mousemove\", callback);\n          canvas.addEventListener(\"mousedown\", callback);\n          canvas.addEventListener(\"mouseup\", callback);\n          return () => {\n            canvas.removeEventListener(\"mouseover\", callback);\n            canvas.removeEventListener(\"mouseout\", callback);\n            canvas.removeEventListener(\"mousemove\", callback);\n            canvas.removeEventListener(\"mousedown\", callback);\n            canvas.removeEventListener(\"mouseup\", callback);\n          };\n        };\n        /***/\n\n      }\n      /******/\n      ];\n      /************************************************************************/\n\n      /******/\n      // The module cache\n\n      /******/\n\n      var __webpack_module_cache__ = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        var cachedModule = __webpack_module_cache__[moduleId];\n        /******/\n\n        if (cachedModule !== undefined) {\n          /******/\n          return cachedModule.exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/\n          // no module.id needed\n\n          /******/\n          // no module.loaded needed\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /************************************************************************/\n\n      /******/\n\n      /* webpack/runtime/define property getters */\n\n      /******/\n\n\n      (() => {\n        /******/\n        // define getter functions for harmony exports\n\n        /******/\n        __webpack_require__.d = (exports, definition) => {\n          /******/\n          for (var key in definition) {\n            /******/\n            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n              /******/\n              Object.defineProperty(exports, key, {\n                enumerable: true,\n                get: definition[key]\n              });\n              /******/\n            }\n            /******/\n\n          }\n          /******/\n\n        };\n        /******/\n\n      })();\n      /******/\n\n      /******/\n\n      /* webpack/runtime/hasOwnProperty shorthand */\n\n      /******/\n\n\n      (() => {\n        /******/\n        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n        /******/\n\n      })();\n      /******/\n\n      /******/\n\n      /* webpack/runtime/make namespace object */\n\n      /******/\n\n\n      (() => {\n        /******/\n        // define __esModule on exports\n\n        /******/\n        __webpack_require__.r = exports => {\n          /******/\n          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n            /******/\n            Object.defineProperty(exports, Symbol.toStringTag, {\n              value: 'Module'\n            });\n            /******/\n          }\n          /******/\n\n\n          Object.defineProperty(exports, '__esModule', {\n            value: true\n          });\n          /******/\n        };\n        /******/\n\n      })();\n      /******/\n\n      /************************************************************************/\n\n\n      var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n\n      (() => {\n        __webpack_require__.r(__webpack_exports__);\n        /* harmony export */\n\n\n        __webpack_require__.d(__webpack_exports__, {\n          /* harmony export */\n          \"Fit\": () =>\n          /* binding */\n          Fit,\n\n          /* harmony export */\n          \"Alignment\": () =>\n          /* binding */\n          Alignment,\n\n          /* harmony export */\n          \"Layout\": () =>\n          /* binding */\n          Layout,\n\n          /* harmony export */\n          \"RuntimeLoader\": () =>\n          /* binding */\n          RuntimeLoader,\n\n          /* harmony export */\n          \"StateMachineInputType\": () =>\n          /* binding */\n          StateMachineInputType,\n\n          /* harmony export */\n          \"StateMachineInput\": () =>\n          /* binding */\n          StateMachineInput,\n\n          /* harmony export */\n          \"EventType\": () =>\n          /* binding */\n          EventType,\n\n          /* harmony export */\n          \"LoopType\": () =>\n          /* binding */\n          LoopType,\n\n          /* harmony export */\n          \"Rive\": () =>\n          /* binding */\n          Rive,\n\n          /* harmony export */\n          \"Testing\": () =>\n          /* binding */\n          Testing\n          /* harmony export */\n\n        });\n        /* harmony import */\n\n\n        var _rive_advanced_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n        /* harmony import */\n\n\n        var package_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n        /* harmony import */\n\n\n        var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);\n\n        var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n          function adopt(value) {\n            return value instanceof P ? value : new P(function (resolve) {\n              resolve(value);\n            });\n          }\n\n          return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) {\n              try {\n                step(generator.next(value));\n              } catch (e) {\n                reject(e);\n              }\n            }\n\n            function rejected(value) {\n              try {\n                step(generator[\"throw\"](value));\n              } catch (e) {\n                reject(e);\n              }\n            }\n\n            function step(result) {\n              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n            }\n\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n          });\n        };\n\n        var __generator = undefined && undefined.__generator || function (thisArg, body) {\n          var _ = {\n            label: 0,\n            sent: function () {\n              if (t[0] & 1) throw t[1];\n              return t[1];\n            },\n            trys: [],\n            ops: []\n          },\n              f,\n              y,\n              t,\n              g;\n          return g = {\n            next: verb(0),\n            \"throw\": verb(1),\n            \"return\": verb(2)\n          }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n            return this;\n          }), g;\n\n          function verb(n) {\n            return function (v) {\n              return step([n, v]);\n            };\n          }\n\n          function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n\n            while (_) try {\n              if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n              if (y = 0, t) op = [op[0] & 2, t.value];\n\n              switch (op[0]) {\n                case 0:\n                case 1:\n                  t = op;\n                  break;\n\n                case 4:\n                  _.label++;\n                  return {\n                    value: op[1],\n                    done: false\n                  };\n\n                case 5:\n                  _.label++;\n                  y = op[1];\n                  op = [0];\n                  continue;\n\n                case 7:\n                  op = _.ops.pop();\n\n                  _.trys.pop();\n\n                  continue;\n\n                default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                    _ = 0;\n                    continue;\n                  }\n\n                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                    _.label = op[1];\n                    break;\n                  }\n\n                  if (op[0] === 6 && _.label < t[1]) {\n                    _.label = t[1];\n                    t = op;\n                    break;\n                  }\n\n                  if (t && _.label < t[2]) {\n                    _.label = t[2];\n\n                    _.ops.push(op);\n\n                    break;\n                  }\n\n                  if (t[2]) _.ops.pop();\n\n                  _.trys.pop();\n\n                  continue;\n              }\n\n              op = body.call(thisArg, _);\n            } catch (e) {\n              op = [6, e];\n              y = 0;\n            } finally {\n              f = t = 0;\n            }\n\n            if (op[0] & 5) throw op[1];\n            return {\n              value: op[0] ? op[1] : void 0,\n              done: true\n            };\n          }\n        }; // #region layout\n        // Fit options for the canvas\n\n\n        var Fit;\n\n        (function (Fit) {\n          Fit[\"Cover\"] = \"cover\";\n          Fit[\"Contain\"] = \"contain\";\n          Fit[\"Fill\"] = \"fill\";\n          Fit[\"FitWidth\"] = \"fitWidth\";\n          Fit[\"FitHeight\"] = \"fitHeight\";\n          Fit[\"None\"] = \"none\";\n          Fit[\"ScaleDown\"] = \"scaleDown\";\n        })(Fit || (Fit = {})); // Alignment options for the canvas\n\n\n        var Alignment;\n\n        (function (Alignment) {\n          Alignment[\"Center\"] = \"center\";\n          Alignment[\"TopLeft\"] = \"topLeft\";\n          Alignment[\"TopCenter\"] = \"topCenter\";\n          Alignment[\"TopRight\"] = \"topRight\";\n          Alignment[\"CenterLeft\"] = \"centerLeft\";\n          Alignment[\"CenterRight\"] = \"centerRight\";\n          Alignment[\"BottomLeft\"] = \"bottomLeft\";\n          Alignment[\"BottomCenter\"] = \"bottomCenter\";\n          Alignment[\"BottomRight\"] = \"bottomRight\";\n        })(Alignment || (Alignment = {})); // Alignment options for Rive animations in a HTML canvas\n\n\n        var Layout =\n        /** @class */\n        function () {\n          function Layout(params) {\n            var _a, _b, _c, _d, _e, _f;\n\n            this.fit = (_a = params === null || params === void 0 ? void 0 : params.fit) !== null && _a !== void 0 ? _a : Fit.Contain;\n            this.alignment = (_b = params === null || params === void 0 ? void 0 : params.alignment) !== null && _b !== void 0 ? _b : Alignment.Center;\n            this.minX = (_c = params === null || params === void 0 ? void 0 : params.minX) !== null && _c !== void 0 ? _c : 0;\n            this.minY = (_d = params === null || params === void 0 ? void 0 : params.minY) !== null && _d !== void 0 ? _d : 0;\n            this.maxX = (_e = params === null || params === void 0 ? void 0 : params.maxX) !== null && _e !== void 0 ? _e : 0;\n            this.maxY = (_f = params === null || params === void 0 ? void 0 : params.maxY) !== null && _f !== void 0 ? _f : 0;\n          } // Alternative constructor to build a Layout from an interface/object\n\n\n          Layout.new = function (_a) {\n            var fit = _a.fit,\n                alignment = _a.alignment,\n                minX = _a.minX,\n                minY = _a.minY,\n                maxX = _a.maxX,\n                maxY = _a.maxY;\n            console.warn(\"This function is deprecated: please use `new Layout({})` instead\");\n            return new Layout({\n              fit: fit,\n              alignment: alignment,\n              minX: minX,\n              minY: minY,\n              maxX: maxX,\n              maxY: maxY\n            });\n          };\n          /**\n           * Makes a copy of the layout, replacing any specified parameters\n           */\n\n\n          Layout.prototype.copyWith = function (_a) {\n            var fit = _a.fit,\n                alignment = _a.alignment,\n                minX = _a.minX,\n                minY = _a.minY,\n                maxX = _a.maxX,\n                maxY = _a.maxY;\n            return new Layout({\n              fit: fit !== null && fit !== void 0 ? fit : this.fit,\n              alignment: alignment !== null && alignment !== void 0 ? alignment : this.alignment,\n              minX: minX !== null && minX !== void 0 ? minX : this.minX,\n              minY: minY !== null && minY !== void 0 ? minY : this.minY,\n              maxX: maxX !== null && maxX !== void 0 ? maxX : this.maxX,\n              maxY: maxY !== null && maxY !== void 0 ? maxY : this.maxY\n            });\n          }; // Returns fit for the Wasm runtime format\n\n\n          Layout.prototype.runtimeFit = function (rive) {\n            if (this.cachedRuntimeFit) return this.cachedRuntimeFit;\n            var fit;\n            if (this.fit === Fit.Cover) fit = rive.Fit.cover;else if (this.fit === Fit.Contain) fit = rive.Fit.contain;else if (this.fit === Fit.Fill) fit = rive.Fit.fill;else if (this.fit === Fit.FitWidth) fit = rive.Fit.fitWidth;else if (this.fit === Fit.FitHeight) fit = rive.Fit.fitHeight;else if (this.fit === Fit.ScaleDown) fit = rive.Fit.scaleDown;else fit = rive.Fit.none;\n            this.cachedRuntimeFit = fit;\n            return fit;\n          }; // Returns alignment for the Wasm runtime format\n\n\n          Layout.prototype.runtimeAlignment = function (rive) {\n            if (this.cachedRuntimeAlignment) return this.cachedRuntimeAlignment;\n            var alignment;\n            if (this.alignment === Alignment.TopLeft) alignment = rive.Alignment.topLeft;else if (this.alignment === Alignment.TopCenter) alignment = rive.Alignment.topCenter;else if (this.alignment === Alignment.TopRight) alignment = rive.Alignment.topRight;else if (this.alignment === Alignment.CenterLeft) alignment = rive.Alignment.centerLeft;else if (this.alignment === Alignment.CenterRight) alignment = rive.Alignment.centerRight;else if (this.alignment === Alignment.BottomLeft) alignment = rive.Alignment.bottomLeft;else if (this.alignment === Alignment.BottomCenter) alignment = rive.Alignment.bottomCenter;else if (this.alignment === Alignment.BottomRight) alignment = rive.Alignment.bottomRight;else alignment = rive.Alignment.center;\n            this.cachedRuntimeAlignment = alignment;\n            return alignment;\n          };\n\n          return Layout;\n        }(); // Runtime singleton; use getInstance to provide a callback that returns the\n        // Rive runtime\n\n\n        var RuntimeLoader =\n        /** @class */\n        function () {\n          // Class is never instantiated\n          function RuntimeLoader() {} // Loads the runtime\n\n\n          RuntimeLoader.loadRuntime = function () {\n            _rive_advanced_mjs__WEBPACK_IMPORTED_MODULE_0__.default({\n              // Loads Wasm bundle\n              locateFile: function () {\n                return RuntimeLoader.wasmURL;\n              }\n            }).then(function (rive) {\n              var _a;\n\n              RuntimeLoader.runtime = rive; // Fire all the callbacks\n\n              while (RuntimeLoader.callBackQueue.length > 0) {\n                (_a = RuntimeLoader.callBackQueue.shift()) === null || _a === void 0 ? void 0 : _a(RuntimeLoader.runtime);\n              }\n            });\n          }; // Provides a runtime instance via a callback\n\n\n          RuntimeLoader.getInstance = function (callback) {\n            // If it's not loading, start loading runtime\n            if (!RuntimeLoader.isLoading) {\n              RuntimeLoader.isLoading = true;\n              RuntimeLoader.loadRuntime();\n            }\n\n            if (!RuntimeLoader.runtime) {\n              RuntimeLoader.callBackQueue.push(callback);\n            } else {\n              callback(RuntimeLoader.runtime);\n            }\n          }; // Provides a runtime instance via a promise\n\n\n          RuntimeLoader.awaitInstance = function () {\n            return new Promise(function (resolve) {\n              return RuntimeLoader.getInstance(function (rive) {\n                return resolve(rive);\n              });\n            });\n          }; // Manually sets the wasm url\n\n\n          RuntimeLoader.setWasmUrl = function (url) {\n            RuntimeLoader.wasmURL = url;\n          }; // Flag to indicate that loading has started/completed\n\n\n          RuntimeLoader.isLoading = false; // List of callbacks for the runtime that come in while loading\n\n          RuntimeLoader.callBackQueue = []; // Path to the Wasm file; default path works for testing only;\n          // if embedded wasm is used then this is never used.\n\n          RuntimeLoader.wasmURL = \"https://unpkg.com/\" + package_json__WEBPACK_IMPORTED_MODULE_1__.name + \"@\" + package_json__WEBPACK_IMPORTED_MODULE_1__.version + \"/rive.wasm\";\n          return RuntimeLoader;\n        }(); // #endregion\n        // #region animations\n        // Wraps animations and instances from the runtime and keeps track of playback\n        // state\n\n\n        var Animation =\n        /** @class */\n        function () {\n          /**\n           * Constructs a new animation\n           * @constructor\n           * @param {any} animation: runtime animation object\n           * @param {any} instance: runtime animation instance object\n           */\n          function Animation(animation, artboard, runtime, playing) {\n            this.animation = animation;\n            this.artboard = artboard;\n            this.playing = playing;\n            this.loopCount = 0; // Time to which the animation should move to on the next render\n\n            this.scrubTo = null;\n            this.instance = new runtime.LinearAnimationInstance(animation, artboard);\n          }\n\n          Object.defineProperty(Animation.prototype, \"name\", {\n            // Returns the animation's name\n            get: function () {\n              return this.animation.name;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Animation.prototype, \"time\", {\n            // Returns the animation's current time\n            get: function () {\n              return this.instance.time;\n            },\n            // Sets the animation's current time\n            set: function (value) {\n              this.instance.time = value;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Animation.prototype, \"loopValue\", {\n            // Returns the animation's loop type\n            get: function () {\n              return this.animation.loopValue;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * Advances the animation by the give time. If the animation needs scrubbing,\n           * time is ignored and the stored scrub value is used.\n           * @param time the time to advance the animation by if no scrubbing required\n           */\n\n          Animation.prototype.advance = function (time) {\n            if (this.scrubTo === null) {\n              this.instance.advance(time);\n            } else {\n              this.instance.time = 0;\n              this.instance.advance(this.scrubTo);\n              this.scrubTo = null;\n            }\n          };\n          /**\n           * Apply interpolated keyframe values to the artboard. This should be called after calling\n           * .advance() on an animation instance so that new values are applied to properties.\n           *\n           * Note: This does not advance the artboard, which updates all objects on the artboard\n           * @param mix - Mix value for the animation from 0 to 1\n           */\n\n\n          Animation.prototype.apply = function (mix) {\n            this.instance.apply(mix);\n          };\n\n          Object.defineProperty(Animation.prototype, \"needsScrub\", {\n            get: function () {\n              return this.scrubTo !== null;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * Deletes the backing Wasm animation instance; once this is called, this\n           * animation is no more.\n           */\n\n          Animation.prototype.cleanup = function () {\n            this.instance.delete();\n          };\n\n          return Animation;\n        }(); // #endregion\n        // #region state machines\n\n\n        var StateMachineInputType;\n\n        (function (StateMachineInputType) {\n          StateMachineInputType[StateMachineInputType[\"Number\"] = 56] = \"Number\";\n          StateMachineInputType[StateMachineInputType[\"Trigger\"] = 58] = \"Trigger\";\n          StateMachineInputType[StateMachineInputType[\"Boolean\"] = 59] = \"Boolean\";\n        })(StateMachineInputType || (StateMachineInputType = {}));\n        /**\n         * An input for a state machine\n         */\n\n\n        var StateMachineInput =\n        /** @class */\n        function () {\n          function StateMachineInput(type, runtimeInput) {\n            this.type = type;\n            this.runtimeInput = runtimeInput;\n          }\n\n          Object.defineProperty(StateMachineInput.prototype, \"name\", {\n            /**\n             * Returns the name of the input\n             */\n            get: function () {\n              return this.runtimeInput.name;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(StateMachineInput.prototype, \"value\", {\n            /**\n             * Returns the current value of the input\n             */\n            get: function () {\n              return this.runtimeInput.value;\n            },\n\n            /**\n             * Sets the value of the input\n             */\n            set: function (value) {\n              this.runtimeInput.value = value;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * Fires a trigger; does nothing on Number or Boolean input types\n           */\n\n          StateMachineInput.prototype.fire = function () {\n            if (this.type === StateMachineInputType.Trigger) {\n              this.runtimeInput.fire();\n            }\n          };\n\n          return StateMachineInput;\n        }();\n\n        var StateMachine =\n        /** @class */\n        function () {\n          /**\n           * @constructor\n           * @param stateMachine runtime state machine object\n           * @param instance runtime state machine instance object\n           */\n          function StateMachine(stateMachine, runtime, playing, artboard) {\n            this.stateMachine = stateMachine;\n            this.playing = playing;\n            this.artboard = artboard;\n            /**\n             * Caches the inputs from the runtime\n             */\n\n            this.inputs = [];\n            this.instance = new runtime.StateMachineInstance(stateMachine, artboard);\n            this.initInputs(runtime);\n          }\n\n          Object.defineProperty(StateMachine.prototype, \"name\", {\n            get: function () {\n              return this.stateMachine.name;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(StateMachine.prototype, \"statesChanged\", {\n            /**\n             * Returns a list of state names that have changed on this frame\n             */\n            get: function () {\n              var names = [];\n\n              for (var i = 0; i < this.instance.stateChangedCount(); i++) {\n                names.push(this.instance.stateChangedNameByIndex(i));\n              }\n\n              return names;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * Advances the state machine instance by a given time.\n           * @param time - the time to advance the animation by in seconds\n           */\n\n          StateMachine.prototype.advance = function (time) {\n            this.instance.advance(time);\n          };\n          /**\n           * Fetches references to the state machine's inputs and caches them\n           * @param runtime an instance of the runtime; needed for the SMIInput types\n           */\n\n\n          StateMachine.prototype.initInputs = function (runtime) {\n            // Fetch the inputs from the runtime if we don't have them\n            for (var i = 0; i < this.instance.inputCount(); i++) {\n              var input = this.instance.input(i);\n              this.inputs.push(this.mapRuntimeInput(input, runtime));\n            }\n          };\n          /**\n           * Maps a runtime input to it's appropriate type\n           * @param input\n           */\n\n\n          StateMachine.prototype.mapRuntimeInput = function (input, runtime) {\n            if (input.type === runtime.SMIInput.bool) {\n              return new StateMachineInput(StateMachineInputType.Boolean, input.asBool());\n            } else if (input.type === runtime.SMIInput.number) {\n              return new StateMachineInput(StateMachineInputType.Number, input.asNumber());\n            } else if (input.type === runtime.SMIInput.trigger) {\n              return new StateMachineInput(StateMachineInputType.Trigger, input.asTrigger());\n            }\n          };\n          /**\n           * Deletes the backing Wasm state machine instance; once this is called, this\n           * state machine is no more.\n           */\n\n\n          StateMachine.prototype.cleanup = function () {\n            this.instance.delete();\n          };\n\n          return StateMachine;\n        }(); // #endregion\n        // #region animator\n\n        /**\n         * Manages animation\n         */\n\n\n        var Animator =\n        /** @class */\n        function () {\n          /**\n           * Constructs a new animator\n           * @constructor\n           * @param runtime Rive runtime; needed to instance animations & state machines\n           * @param artboard the artboard that holds all animations and state machines\n           * @param animations optional list of animations\n           * @param stateMachines optional list of state machines\n           */\n          function Animator(runtime, artboard, eventManager, animations, stateMachines) {\n            if (animations === void 0) {\n              animations = [];\n            }\n\n            if (stateMachines === void 0) {\n              stateMachines = [];\n            }\n\n            this.runtime = runtime;\n            this.artboard = artboard;\n            this.eventManager = eventManager;\n            this.animations = animations;\n            this.stateMachines = stateMachines;\n          }\n          /**\n           * Adds animations and state machines by their names. If names are shared\n           * between animations & state machines, then the first one found will be\n           * created. Best not to use the same names for these in your Rive file.\n           * @param animatable the name(s) of animations and state machines to add\n           * @returns a list of names of the playing animations and state machines\n           */\n\n\n          Animator.prototype.add = function (animatables, playing, fireEvent) {\n            if (fireEvent === void 0) {\n              fireEvent = true;\n            }\n\n            animatables = mapToStringArray(animatables); // If animatables is empty, play or pause everything\n\n            if (animatables.length === 0) {\n              this.animations.forEach(function (a) {\n                return a.playing = playing;\n              });\n              this.stateMachines.forEach(function (m) {\n                return m.playing = playing;\n              });\n            } else {\n              // Play/pause already instanced items, or create new instances\n              var instancedAnimationNames = this.animations.map(function (a) {\n                return a.name;\n              });\n              var instancedMachineNames = this.stateMachines.map(function (m) {\n                return m.name;\n              });\n\n              for (var i in animatables) {\n                var aIndex = instancedAnimationNames.indexOf(animatables[i]);\n                var mIndex = instancedMachineNames.indexOf(animatables[i]);\n\n                if (aIndex >= 0 || mIndex >= 0) {\n                  if (aIndex >= 0) {\n                    // Animation is instanced, play/pause it\n                    this.animations[aIndex].playing = playing;\n                  } else {\n                    // State machine is instanced, play/pause it\n                    this.stateMachines[mIndex].playing = playing;\n                  }\n                } else {\n                  // Try to create a new animation instance\n                  var anim = this.artboard.animationByName(animatables[i]);\n\n                  if (anim) {\n                    var newAnimation = new Animation(anim, this.artboard, this.runtime, playing); // Display the first frame of the specified animation\n\n                    newAnimation.advance(0);\n                    newAnimation.apply(1.0);\n                    this.animations.push(newAnimation);\n                  } else {\n                    // Try to create a new state machine instance\n                    var sm = this.artboard.stateMachineByName(animatables[i]);\n\n                    if (sm) {\n                      var newStateMachine = new StateMachine(sm, this.runtime, playing, this.artboard);\n                      this.stateMachines.push(newStateMachine);\n                    }\n                  }\n                }\n              }\n            } // Fire play/paused events for animations\n\n\n            if (fireEvent) {\n              if (playing) {\n                this.eventManager.fire({\n                  type: EventType.Play,\n                  data: this.playing\n                });\n              } else {\n                this.eventManager.fire({\n                  type: EventType.Pause,\n                  data: this.paused\n                });\n              }\n            }\n\n            return playing ? this.playing : this.paused;\n          };\n          /**\n           * Play the named animations/state machines\n           * @param animatables the names of the animations/machines to play; plays all if empty\n           * @returns a list of the playing items\n           */\n\n\n          Animator.prototype.play = function (animatables) {\n            return this.add(animatables, true);\n          };\n          /**\n           * Pauses named animations and state machines, or everything if nothing is\n           * specified\n           * @param animatables names of the animations and state machines to pause\n           * @returns a list of names of the animations and state machines paused\n           */\n\n\n          Animator.prototype.pause = function (animatables) {\n            return this.add(animatables, false);\n          };\n          /**\n           * Set time of named animations\n           * @param animations names of the animations to scrub\n           * @param value time scrub value, a floating point number to which the playhead is jumped\n           * @returns a list of names of the animations that were scrubbed\n           */\n\n\n          Animator.prototype.scrub = function (animatables, value) {\n            var forScrubbing = this.animations.filter(function (a) {\n              return animatables.includes(a.name);\n            });\n            forScrubbing.forEach(function (a) {\n              return a.scrubTo = value;\n            });\n            return forScrubbing.map(function (a) {\n              return a.name;\n            });\n          };\n\n          Object.defineProperty(Animator.prototype, \"playing\", {\n            /**\n             * Returns a list of names of all animations and state machines currently\n             * playing\n             */\n            get: function () {\n              return this.animations.filter(function (a) {\n                return a.playing;\n              }).map(function (a) {\n                return a.name;\n              }).concat(this.stateMachines.filter(function (m) {\n                return m.playing;\n              }).map(function (m) {\n                return m.name;\n              }));\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Animator.prototype, \"paused\", {\n            /**\n             * Returns a list of names of all animations and state machines currently\n             * paused\n             */\n            get: function () {\n              return this.animations.filter(function (a) {\n                return !a.playing;\n              }).map(function (a) {\n                return a.name;\n              }).concat(this.stateMachines.filter(function (m) {\n                return !m.playing;\n              }).map(function (m) {\n                return m.name;\n              }));\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * Stops and removes all named animations and state machines\n           * @param animatables animations and state machines to remove\n           * @returns a list of names of removed items\n           */\n\n          Animator.prototype.stop = function (animatables) {\n            var _this = this;\n\n            animatables = mapToStringArray(animatables); // If nothing's specified, wipe them out, all of them\n\n            var removedNames = []; // Stop everything\n\n            if (animatables.length === 0) {\n              removedNames = this.animations.map(function (a) {\n                return a.name;\n              }).concat(this.stateMachines.map(function (m) {\n                return m.name;\n              })); // Clean up before emptying the arrays\n\n              this.animations.forEach(function (a) {\n                return a.cleanup();\n              });\n              this.stateMachines.forEach(function (m) {\n                return m.cleanup();\n              }); // Empty out the arrays\n\n              this.animations.splice(0, this.animations.length);\n              this.stateMachines.splice(0, this.stateMachines.length);\n            } else {\n              // Remove only the named animations/state machines\n              var animationsToRemove = this.animations.filter(function (a) {\n                return animatables.includes(a.name);\n              });\n              animationsToRemove.forEach(function (a) {\n                a.cleanup();\n\n                _this.animations.splice(_this.animations.indexOf(a), 1);\n              });\n              var machinesToRemove = this.stateMachines.filter(function (m) {\n                return animatables.includes(m.name);\n              });\n              machinesToRemove.forEach(function (m) {\n                m.cleanup();\n\n                _this.stateMachines.splice(_this.stateMachines.indexOf(m), 1);\n              });\n              removedNames = animationsToRemove.map(function (a) {\n                return a.name;\n              }).concat(machinesToRemove.map(function (m) {\n                return m.name;\n              }));\n            }\n\n            this.eventManager.fire({\n              type: EventType.Stop,\n              data: removedNames\n            }); // Return the list of animations removed\n\n            return removedNames;\n          };\n\n          Object.defineProperty(Animator.prototype, \"isPlaying\", {\n            /**\n             * Returns true if at least one animation is active\n             */\n            get: function () {\n              return this.animations.reduce(function (acc, curr) {\n                return acc || curr.playing;\n              }, false) || this.stateMachines.reduce(function (acc, curr) {\n                return acc || curr.playing;\n              }, false);\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Animator.prototype, \"isPaused\", {\n            /**\n             * Returns true if all animations are paused and there's at least one animation\n             */\n            get: function () {\n              return !this.isPlaying && (this.animations.length > 0 || this.stateMachines.length > 0);\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Animator.prototype, \"isStopped\", {\n            /**\n             * Returns true if there are no playing or paused animations/state machines\n             */\n            get: function () {\n              return this.animations.length === 0 && this.stateMachines.length === 0;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * If there are no animations or state machines, add the first one found\n           * @returns the name of the animation or state machine instanced\n           */\n\n          Animator.prototype.atLeastOne = function (playing, fireEvent) {\n            if (fireEvent === void 0) {\n              fireEvent = true;\n            }\n\n            var instancedName;\n\n            if (this.animations.length === 0 && this.stateMachines.length === 0) {\n              if (this.artboard.animationCount() > 0) {\n                // Add the first animation\n                this.add([instancedName = this.artboard.animationByIndex(0).name], playing, fireEvent);\n              } else if (this.artboard.stateMachineCount() > 0) {\n                // Add the first state machine\n                this.add([instancedName = this.artboard.stateMachineByIndex(0).name], playing, fireEvent);\n              }\n            }\n\n            return instancedName;\n          };\n          /**\n           * Checks if any animations have looped and if so, fire the appropriate event\n           */\n\n\n          Animator.prototype.handleLooping = function () {\n            for (var _i = 0, _a = this.animations.filter(function (a) {\n              return a.playing;\n            }); _i < _a.length; _i++) {\n              var animation = _a[_i]; // Emit if the animation looped\n\n              if (animation.loopValue === 0 && animation.loopCount) {\n                animation.loopCount = 0; // This is a one-shot; if it has ended, delete the instance\n\n                this.stop(animation.name);\n              } else if (animation.loopValue === 1 && animation.loopCount) {\n                this.eventManager.fire({\n                  type: EventType.Loop,\n                  data: {\n                    animation: animation.name,\n                    type: LoopType.Loop\n                  }\n                });\n                animation.loopCount = 0;\n              } // Wasm indicates a loop at each time the animation\n              // changes direction, so a full loop/lap occurs every\n              // two loop counts\n              else if (animation.loopValue === 2 && animation.loopCount > 1) {\n                this.eventManager.fire({\n                  type: EventType.Loop,\n                  data: {\n                    animation: animation.name,\n                    type: LoopType.PingPong\n                  }\n                });\n                animation.loopCount = 0;\n              }\n            }\n          };\n          /**\n           * Checks if states have changed in state machines and fires a statechange\n           * event\n           */\n\n\n          Animator.prototype.handleStateChanges = function () {\n            var statesChanged = [];\n\n            for (var _i = 0, _a = this.stateMachines.filter(function (sm) {\n              return sm.playing;\n            }); _i < _a.length; _i++) {\n              var stateMachine = _a[_i];\n              statesChanged.push.apply(statesChanged, stateMachine.statesChanged);\n            }\n\n            if (statesChanged.length > 0) {\n              this.eventManager.fire({\n                type: EventType.StateChange,\n                data: statesChanged\n              });\n            }\n          };\n\n          return Animator;\n        }(); // #endregion\n        // #region events\n\n        /**\n         * Supported event types triggered in Rive\n         */\n\n\n        var EventType;\n\n        (function (EventType) {\n          EventType[\"Load\"] = \"load\";\n          EventType[\"LoadError\"] = \"loaderror\";\n          EventType[\"Play\"] = \"play\";\n          EventType[\"Pause\"] = \"pause\";\n          EventType[\"Stop\"] = \"stop\";\n          EventType[\"Loop\"] = \"loop\";\n          EventType[\"Draw\"] = \"draw\";\n          EventType[\"StateChange\"] = \"statechange\";\n        })(EventType || (EventType = {}));\n        /**\n         * Looping types: one-shot, loop, and ping-pong\n         */\n\n\n        var LoopType;\n\n        (function (LoopType) {\n          LoopType[\"OneShot\"] = \"oneshot\";\n          LoopType[\"Loop\"] = \"loop\";\n          LoopType[\"PingPong\"] = \"pingpong\";\n        })(LoopType || (LoopType = {})); // Manages Rive events and listeners\n\n\n        var EventManager =\n        /** @class */\n        function () {\n          function EventManager(listeners) {\n            if (listeners === void 0) {\n              listeners = [];\n            }\n\n            this.listeners = listeners;\n          } // Gets listeners of specified type\n\n\n          EventManager.prototype.getListeners = function (type) {\n            return this.listeners.filter(function (e) {\n              return e.type === type;\n            });\n          }; // Adds a listener\n\n\n          EventManager.prototype.add = function (listener) {\n            if (!this.listeners.includes(listener)) {\n              this.listeners.push(listener);\n            }\n          };\n          /**\n           * Removes a listener\n           * @param listener the listener with the callback to be removed\n           */\n\n\n          EventManager.prototype.remove = function (listener) {\n            // We can't simply look for the listener as it'll be a different instance to\n            // one originally subscribed. Find all the listeners of the right type and\n            // then check their callbacks which should match.\n            for (var i = 0; i < this.listeners.length; i++) {\n              var currentListener = this.listeners[i];\n\n              if (currentListener.type === listener.type) {\n                if (currentListener.callback === listener.callback) {\n                  this.listeners.splice(i, 1);\n                  break;\n                }\n              }\n            }\n          };\n          /**\n           * Clears all listeners of specified type, or every listener if no type is\n           * specified\n           * @param type the type of listeners to clear, or all listeners if not\n           * specified\n           */\n\n\n          EventManager.prototype.removeAll = function (type) {\n            var _this = this;\n\n            if (!type) {\n              this.listeners.splice(0, this.listeners.length);\n            } else {\n              this.listeners.filter(function (l) {\n                return l.type === type;\n              }).forEach(function (l) {\n                return _this.remove(l);\n              });\n            }\n          }; // Fires an event\n\n\n          EventManager.prototype.fire = function (event) {\n            var eventListeners = this.getListeners(event.type);\n            eventListeners.forEach(function (listener) {\n              return listener.callback(event);\n            });\n          };\n\n          return EventManager;\n        }(); // Manages a queue of tasks\n\n\n        var TaskQueueManager =\n        /** @class */\n        function () {\n          function TaskQueueManager(eventManager) {\n            this.eventManager = eventManager;\n            this.queue = [];\n          } // Adds a task top the queue\n\n\n          TaskQueueManager.prototype.add = function (task) {\n            this.queue.push(task);\n          }; // Processes all tasks in the queue\n\n\n          TaskQueueManager.prototype.process = function () {\n            while (this.queue.length > 0) {\n              var task = this.queue.shift();\n\n              if (task === null || task === void 0 ? void 0 : task.action) {\n                task.action();\n              }\n\n              if (task === null || task === void 0 ? void 0 : task.event) {\n                this.eventManager.fire(task.event);\n              }\n            }\n          };\n\n          return TaskQueueManager;\n        }();\n\n        var Rive =\n        /** @class */\n        function () {\n          function Rive(params) {\n            var _a; // Flag to indicate if the layout has changed; used by the renderer to know\n            // when to align\n\n\n            this._updateLayout = true;\n            /**\n             * Flag to active/deactivate renderer\n             */\n\n            this.isRendererActive = true; // Tracks if a Rive file is loaded\n\n            this.loaded = false;\n            /**\n             * Tracks if a Rive file is loaded; we need this in addition to loaded as some\n             * commands (e.g. contents) can be called as soon as the file is loaded.\n             * However, playback commands need to be queued and run in order once initial\n             * animations and autoplay has been sorted out. This applies to play, pause,\n             * and start.\n             */\n\n            this.readyForPlaying = false; // Runtime artboard\n\n            this.artboard = null; // place to clear up event listeners\n\n            this.eventCleanup = null; // Durations to generate a frame for the last second. Used for performance profiling.\n\n            this.durations = [];\n            this.frameTimes = [];\n            this.frameCount = 0;\n            /**\n             * Used be draw to track when a second of active rendering time has passed.\n             * Used for debugging purposes\n             */\n\n            this.renderSecondTimer = 0;\n            this.canvas = params.canvas;\n            this.src = params.src;\n            this.buffer = params.buffer;\n            this.layout = (_a = params.layout) !== null && _a !== void 0 ? _a : new Layout(); // New event management system\n\n            this.eventManager = new EventManager();\n            if (params.onLoad) this.on(EventType.Load, params.onLoad);\n            if (params.onLoadError) this.on(EventType.LoadError, params.onLoadError);\n            if (params.onPlay) this.on(EventType.Play, params.onPlay);\n            if (params.onPause) this.on(EventType.Pause, params.onPause);\n            if (params.onStop) this.on(EventType.Stop, params.onStop);\n            if (params.onLoop) this.on(EventType.Loop, params.onLoop);\n            if (params.onStateChange) this.on(EventType.StateChange, params.onStateChange);\n            /**\n             * @deprecated Use camelCase'd versions instead.\n             */\n\n            if (params.onload && !params.onLoad) this.on(EventType.Load, params.onload);\n            if (params.onloaderror && !params.onLoadError) this.on(EventType.LoadError, params.onloaderror);\n            if (params.onplay && !params.onPlay) this.on(EventType.Play, params.onplay);\n            if (params.onpause && !params.onPause) this.on(EventType.Pause, params.onpause);\n            if (params.onstop && !params.onStop) this.on(EventType.Stop, params.onstop);\n            if (params.onloop && !params.onLoop) this.on(EventType.Loop, params.onloop);\n            if (params.onstatechange && !params.onStateChange) this.on(EventType.StateChange, params.onstatechange); // Hook up the task queue\n\n            this.taskQueue = new TaskQueueManager(this.eventManager);\n            this.init({\n              src: this.src,\n              buffer: this.buffer,\n              autoplay: params.autoplay,\n              animations: params.animations,\n              stateMachines: params.stateMachines,\n              artboard: params.artboard,\n              useOffscreenRenderer: params.useOffscreenRenderer\n            });\n          } // Alternative constructor to build a Rive instance from an interface/object\n\n\n          Rive.new = function (params) {\n            console.warn(\"This function is deprecated: please use `new Rive({})` instead\");\n            return new Rive(params);\n          }; // Initializes the Rive object either from constructor or load()\n\n\n          Rive.prototype.init = function (_a) {\n            var _this = this;\n\n            var src = _a.src,\n                buffer = _a.buffer,\n                animations = _a.animations,\n                stateMachines = _a.stateMachines,\n                artboard = _a.artboard,\n                _b = _a.autoplay,\n                autoplay = _b === void 0 ? false : _b,\n                _c = _a.useOffscreenRenderer,\n                useOffscreenRenderer = _c === void 0 ? false : _c;\n            this.src = src;\n            this.buffer = buffer; // If no source file url specified, it's a bust\n\n            if (!this.src && !this.buffer) {\n              throw new Error(Rive.missingErrorMessage);\n            } // List of animations that should be initialized.\n\n\n            var startingAnimationNames = mapToStringArray(animations); // List of state machines that should be initialized\n\n            var startingStateMachineNames = mapToStringArray(stateMachines); // Ensure loaded is marked as false if loading new file\n\n            this.loaded = false;\n            this.readyForPlaying = false; // Ensure the runtime is loaded\n\n            RuntimeLoader.awaitInstance().then(function (runtime) {\n              _this.runtime = runtime; // Get the canvas where you want to render the animation and create a renderer\n\n              _this.renderer = _this.runtime.makeRenderer(_this.canvas, useOffscreenRenderer); // Initial size adjustment based on devicePixelRatio if no width/height are\n              // specified explicitly\n\n              if (!(_this.canvas.width || _this.canvas.height)) {\n                _this.resizeDrawingSurfaceToCanvas();\n              } // Load Rive data from a source uri or a data buffer\n\n\n              _this.initData(artboard, startingAnimationNames, startingStateMachineNames, autoplay).then(function () {\n                var activeStateMachineInstances = (_this.animator.stateMachines || []).filter(function (sm) {\n                  return sm.playing;\n                }).map(function (sm) {\n                  return sm.instance;\n                });\n                _this.eventCleanup = (0, _utils__WEBPACK_IMPORTED_MODULE_2__.registerTouchInteractions)({\n                  canvas: _this.canvas,\n                  artboard: _this.artboard,\n                  stateMachines: activeStateMachineInstances,\n                  renderer: _this.renderer,\n                  rive: _this.runtime,\n                  fit: _this._layout.runtimeFit(_this.runtime),\n                  alignment: _this._layout.runtimeAlignment(_this.runtime)\n                });\n              }).catch(function (e) {\n                console.error(e);\n              });\n            }).catch(function (e) {\n              console.error(e);\n            });\n          }; // Initializes runtime with Rive data and preps for playing\n\n\n          Rive.prototype.initData = function (artboardName, animationNames, stateMachineNames, autoplay) {\n            var _a;\n\n            return __awaiter(this, void 0, void 0, function () {\n              var _b, _c, msg;\n\n              return __generator(this, function (_d) {\n                switch (_d.label) {\n                  case 0:\n                    if (!this.src) return [3\n                    /*break*/\n                    , 2];\n                    _b = this;\n                    return [4\n                    /*yield*/\n                    , loadRiveFile(this.src)];\n\n                  case 1:\n                    _b.buffer = _d.sent();\n                    _d.label = 2;\n\n                  case 2:\n                    // Load the Rive file\n                    _c = this;\n                    return [4\n                    /*yield*/\n                    , this.runtime.load(new Uint8Array(this.buffer))];\n\n                  case 3:\n                    // Load the Rive file\n                    _c.file = _d.sent();\n\n                    if (this.file) {\n                      // Initialize and draw frame\n                      this.initArtboard(artboardName, animationNames, stateMachineNames, autoplay); // Everything's set up, emit a load event\n\n                      this.loaded = true;\n                      this.eventManager.fire({\n                        type: EventType.Load,\n                        data: (_a = this.src) !== null && _a !== void 0 ? _a : \"buffer\"\n                      }); // Flag ready for playback commands and clear the task queue; this order\n                      // is important or it may infinitely recurse\n\n                      this.readyForPlaying = true;\n                      this.taskQueue.process();\n                      this.drawFrame();\n                      return [2\n                      /*return*/\n                      , Promise.resolve()];\n                    } else {\n                      msg = \"Problem loading file; may be corrupt!\";\n                      console.warn(msg);\n                      this.eventManager.fire({\n                        type: EventType.LoadError,\n                        data: msg\n                      });\n                      return [2\n                      /*return*/\n                      , Promise.reject(msg)];\n                    }\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }; // Initialize for playback\n\n\n          Rive.prototype.initArtboard = function (artboardName, animationNames, stateMachineNames, autoplay) {\n            // Fetch the artboard\n            var rootArtboard = artboardName ? this.file.artboardByName(artboardName) : this.file.defaultArtboard(); // Check we have a working artboard\n\n            if (!rootArtboard) {\n              var msg = \"Invalid artboard name or no default artboard\";\n              console.warn(msg);\n              this.eventManager.fire({\n                type: EventType.LoadError,\n                data: msg\n              });\n              return;\n            }\n\n            this.artboard = rootArtboard; // Check that the artboard has at least 1 animation\n\n            if (this.artboard.animationCount() < 1) {\n              var msg = \"Artboard has no animations\";\n              this.eventManager.fire({\n                type: EventType.LoadError,\n                data: msg\n              });\n              throw msg;\n            } // Initialize the animator\n\n\n            this.animator = new Animator(this.runtime, this.artboard, this.eventManager); // Initialize the animations; as loaded hasn't happened yet, we need to\n            // suppress firing the play/pause events until the load event has fired. To\n            // do this we tell the animator to suppress firing events, and add event\n            // firing to the task queue.\n\n            var instanceNames;\n\n            if (animationNames.length > 0 || stateMachineNames.length > 0) {\n              instanceNames = animationNames.concat(stateMachineNames);\n              this.animator.add(instanceNames, autoplay, false);\n            } else {\n              instanceNames = [this.animator.atLeastOne(autoplay, false)];\n            } // Queue up firing the playback events\n\n\n            this.taskQueue.add({\n              event: {\n                type: autoplay ? EventType.Play : EventType.Pause,\n                data: instanceNames\n              }\n            });\n          }; // Draws the current artboard frame\n\n\n          Rive.prototype.drawFrame = function () {\n            this.startRendering();\n          };\n          /**\n           * Draw rendering loop; renders animation frames at the correct time interval.\n           * @param time the time at which to render a frame\n           */\n\n\n          Rive.prototype.draw = function (time, onSecond) {\n            var before = performance.now(); // Clear the frameRequestId, as we're now rendering a fresh frame\n\n            this.frameRequestId = null; // On the first pass, make sure lastTime has a valid value\n\n            if (!this.lastRenderTime) {\n              this.lastRenderTime = time;\n            } // Handle the onSecond callback\n\n\n            this.renderSecondTimer += time - this.lastRenderTime;\n\n            if (this.renderSecondTimer > 5000) {\n              this.renderSecondTimer = 0;\n              onSecond === null || onSecond === void 0 ? void 0 : onSecond();\n            } // Calculate the elapsed time between frames in seconds\n\n\n            var elapsedTime = (time - this.lastRenderTime) / 1000;\n            this.lastRenderTime = time; // - Advance non-paused animations by the elapsed number of seconds\n            // - Advance any animations that require scrubbing\n            // - Advance to the first frame even when autoplay is false\n\n            var activeAnimations = this.animator.animations.filter(function (a) {\n              return a.playing || a.needsScrub;\n            }) // The scrubbed animations must be applied first to prevent weird artifacts\n            // if the playing animations conflict with the scrubbed animating attribuates.\n            .sort(function (first) {\n              return first.needsScrub ? -1 : 1;\n            });\n\n            for (var _i = 0, activeAnimations_1 = activeAnimations; _i < activeAnimations_1.length; _i++) {\n              var animation = activeAnimations_1[_i];\n              animation.advance(elapsedTime);\n\n              if (animation.instance.didLoop) {\n                animation.loopCount += 1;\n              }\n\n              animation.apply(1.0);\n            } // - Advance non-paused state machines by the elapsed number of seconds\n            // - Advance to the first frame even when autoplay is false\n\n\n            var activeStateMachines = this.animator.stateMachines.filter(function (a) {\n              return a.playing;\n            });\n\n            for (var _a = 0, activeStateMachines_1 = activeStateMachines; _a < activeStateMachines_1.length; _a++) {\n              var stateMachine = activeStateMachines_1[_a];\n              stateMachine.advance(elapsedTime); // stateMachine.instance.apply(this.artboard);\n            } // Once the animations have been applied to the artboard, advance it\n            // by the elapsed time.\n\n\n            this.artboard.advance(elapsedTime);\n            var renderer = this.renderer; // Canvas must be wiped to prevent artifacts\n\n            renderer.clear();\n            renderer.save(); // Update the renderer alignment if necessary\n\n            this.alignRenderer();\n            this.artboard.draw(renderer);\n            renderer.restore();\n            renderer.flush(); // Check for any animations that looped\n\n            this.animator.handleLooping(); // Check for any state machines that had a state change\n\n            this.animator.handleStateChanges(); // Add duration to create frame to durations array\n\n            this.frameCount++;\n            var after = performance.now();\n            this.frameTimes.push(after);\n            this.durations.push(after - before);\n\n            while (this.frameTimes[0] <= after - 1000) {\n              this.frameTimes.shift();\n              this.durations.shift();\n            } // Calling requestAnimationFrame will rerun draw() at the correct rate:\n            // https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations\n\n\n            if (this.animator.isPlaying) {\n              // Request a new rendering frame\n              this.startRendering();\n            } else if (this.animator.isPaused) {\n              // Reset the end time so on playback it starts at the correct frame\n              this.lastRenderTime = 0;\n            } else if (this.animator.isStopped) {\n              // Reset animation instances, artboard and time\n              // TODO: implement this properly when we have instancing\n              // this.initArtboard();\n              // this.drawFrame();\n              this.lastRenderTime = 0;\n            }\n          };\n          /**\n           * Align the renderer\n           */\n\n\n          Rive.prototype.alignRenderer = function () {\n            var _a = this,\n                renderer = _a.renderer,\n                runtime = _a.runtime,\n                _layout = _a._layout,\n                artboard = _a.artboard; // Align things up safe in the knowledge we can restore if changed\n\n\n            renderer.align(_layout.runtimeFit(runtime), _layout.runtimeAlignment(runtime), {\n              minX: _layout.minX,\n              minY: _layout.minY,\n              maxX: _layout.maxX,\n              maxY: _layout.maxY\n            }, artboard.bounds);\n          };\n\n          Object.defineProperty(Rive.prototype, \"fps\", {\n            get: function () {\n              return this.durations.length;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"frameTime\", {\n            get: function () {\n              if (this.durations.length === 0) {\n                return 0;\n              }\n\n              return (this.durations.reduce(function (a, b) {\n                return a + b;\n              }, 0) / this.durations.length).toFixed(4);\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * Cleans up all Wasm-generated objects that need to be manually destroyed:\n           * artboard instances, animation instances, state machine instances,\n           * renderer instance, file and runtime.\n           *\n           * Once this is called, you will need to initialise a new instance of the\n           * Rive class\n           */\n\n          Rive.prototype.cleanup = function () {\n            // Stop the renderer if it hasn't already been stopped.\n            this.stopRendering(); // Clean up any artboard, animation or state machine instances.\n\n            this.cleanupInstances(); // Delete the renderer\n\n            this.renderer.delete(); // Delete the rive file\n\n            this.file.delete();\n          };\n          /**\n           * Cleans up any Wasm-generated objects that need to be manually destroyed:\n           * artboard instances, animation instances, state machine instances.\n           *\n           * Once this is called, things will need to be reinitialized or bad things\n           * might happen.\n           */\n\n\n          Rive.prototype.cleanupInstances = function () {\n            if (this.eventCleanup !== null) {\n              this.eventCleanup();\n            } // Delete all animation and state machine instances\n\n\n            this.stop();\n\n            if (this.artboard) {\n              this.artboard.delete();\n              this.artboard = null;\n            }\n          }; // Plays specified animations; if none specified, it unpauses everything.\n\n\n          Rive.prototype.play = function (animationNames, autoplay) {\n            var _this = this;\n\n            animationNames = mapToStringArray(animationNames); // If the file's not loaded, queue up the play\n\n            if (!this.readyForPlaying) {\n              this.taskQueue.add({\n                action: function () {\n                  return _this.play(animationNames, autoplay);\n                }\n              });\n              return;\n            }\n\n            this.animator.play(animationNames);\n            this.startRendering();\n          }; // Pauses specified animations; if none specified, pauses all.\n\n\n          Rive.prototype.pause = function (animationNames) {\n            var _this = this;\n\n            animationNames = mapToStringArray(animationNames); // If the file's not loaded, early out, nothing to pause\n\n            if (!this.readyForPlaying) {\n              this.taskQueue.add({\n                action: function () {\n                  return _this.pause(animationNames);\n                }\n              });\n              return;\n            }\n\n            this.animator.pause(animationNames);\n          };\n\n          Rive.prototype.scrub = function (animationNames, value) {\n            var _this = this;\n\n            animationNames = mapToStringArray(animationNames); // If the file's not loaded, early out, nothing to pause\n\n            if (!this.readyForPlaying) {\n              this.taskQueue.add({\n                action: function () {\n                  return _this.scrub(animationNames, value);\n                }\n              });\n              return;\n            } // Scrub the animation time; we draw a single frame here so that if\n            // nothing's currently playing, the scrubbed animation is still rendered/\n\n\n            this.animator.scrub(animationNames, value || 0);\n            this.drawFrame();\n          }; // Stops specified animations; if none specifies, stops them all.\n\n\n          Rive.prototype.stop = function (animationNames) {\n            var _this = this;\n\n            animationNames = mapToStringArray(animationNames); // If the file's not loaded, early out, nothing to pause\n\n            if (!this.readyForPlaying) {\n              this.taskQueue.add({\n                action: function () {\n                  return _this.stop(animationNames);\n                }\n              });\n              return;\n            }\n\n            this.animator.stop(animationNames);\n          };\n          /**\n           * Resets the animation\n           * @param artboard the name of the artboard, or default if none given\n           * @param animations the names of animations for playback\n           * @param stateMachines the names of state machines for playback\n           * @param autoplay whether to autoplay when reset, defaults to false\n           *\n           */\n\n\n          Rive.prototype.reset = function (params) {\n            var _a; // Get the current artboard, animations, state machines, and playback states\n\n\n            var artBoardName = params === null || params === void 0 ? void 0 : params.artboard;\n            var animationNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.animations);\n            var stateMachineNames = mapToStringArray(params === null || params === void 0 ? void 0 : params.stateMachines);\n            var autoplay = (_a = params === null || params === void 0 ? void 0 : params.autoplay) !== null && _a !== void 0 ? _a : false; // Stop everything and clean up\n\n            this.cleanupInstances(); // Reinitialize an artboard instance with the state\n\n            this.initArtboard(artBoardName, animationNames, stateMachineNames, autoplay);\n            this.taskQueue.process();\n          }; // Loads a new Rive file, keeping listeners in place\n\n\n          Rive.prototype.load = function (params) {\n            // Stop all animations\n            this.stop(); // Reinitialize\n\n            this.init(params);\n          };\n\n          Object.defineProperty(Rive.prototype, \"layout\", {\n            /**\n             * Returns the current layout. Note that layout should be treated as\n             * immutable. If you want to change the layout, create a new one use the\n             * layout setter\n             */\n            get: function () {\n              return this._layout;\n            },\n            // Sets a new layout\n            set: function (layout) {\n              this._layout = layout; // If the maxX or maxY are 0, then set them to the canvas width and height\n\n              if (!layout.maxX || !layout.maxY) {\n                this.resizeToCanvas();\n              }\n\n              if (this.loaded && !this.animator.isPlaying) {\n                this.drawFrame();\n              }\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * Sets the layout bounds to the current canvas size; this is typically called\n           * when the canvas is resized\n           */\n\n          Rive.prototype.resizeToCanvas = function () {\n            this._layout = this.layout.copyWith({\n              minX: 0,\n              minY: 0,\n              maxX: this.canvas.width,\n              maxY: this.canvas.height\n            });\n          };\n          /**\n           * Accounts for devicePixelRatio as a multiplier to render the size of the canvas drawing surface.\n           * Uses the size of the backing canvas to set new width/height attributes. Need to re-render\n           * and resize the layout to match the new drawing surface afterwards.\n           * Useful function for consumers to include in a window resize listener\n           */\n\n\n          Rive.prototype.resizeDrawingSurfaceToCanvas = function () {\n            if (this.canvas instanceof HTMLCanvasElement && !!window) {\n              var _a = this.canvas.getBoundingClientRect(),\n                  width = _a.width,\n                  height = _a.height;\n\n              var dpr = window.devicePixelRatio || 1;\n              this.canvas.width = dpr * width;\n              this.canvas.height = dpr * height;\n              this.startRendering();\n              this.resizeToCanvas();\n            }\n          };\n\n          Object.defineProperty(Rive.prototype, \"source\", {\n            // Returns the animation source, which may be undefined\n            get: function () {\n              return this.src;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"activeArtboard\", {\n            /**\n             * Returns the name of the active artboard\n             */\n            get: function () {\n              return this.artboard ? this.artboard.name : \"\";\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"animationNames\", {\n            // Returns a list of animation names on the chosen artboard\n            get: function () {\n              // If the file's not loaded, we got nothing to return\n              if (!this.loaded) {\n                return [];\n              }\n\n              var animationNames = [];\n\n              for (var i = 0; i < this.artboard.animationCount(); i++) {\n                animationNames.push(this.artboard.animationByIndex(i).name);\n              }\n\n              return animationNames;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"stateMachineNames\", {\n            /**\n             * Returns a list of state machine names from the current artboard\n             */\n            get: function () {\n              // If the file's not loaded, we got nothing to return\n              if (!this.loaded) {\n                return [];\n              }\n\n              var stateMachineNames = [];\n\n              for (var i = 0; i < this.artboard.stateMachineCount(); i++) {\n                stateMachineNames.push(this.artboard.stateMachineByIndex(i).name);\n              }\n\n              return stateMachineNames;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * Returns the inputs for the specified instanced state machine, or an empty\n           * list if the name is invalid or the state machine is not instanced\n           * @param name the state machine name\n           * @returns the inputs for the named state machine\n           */\n\n          Rive.prototype.stateMachineInputs = function (name) {\n            // If the file's not loaded, early out, nothing to pause\n            if (!this.loaded) {\n              return;\n            }\n\n            var stateMachine = this.animator.stateMachines.find(function (m) {\n              return m.name === name;\n            });\n            return stateMachine === null || stateMachine === void 0 ? void 0 : stateMachine.inputs;\n          };\n\n          Object.defineProperty(Rive.prototype, \"playingStateMachineNames\", {\n            // Returns a list of playing machine names\n            get: function () {\n              // If the file's not loaded, we got nothing to return\n              if (!this.loaded) {\n                return [];\n              }\n\n              return this.animator.stateMachines.filter(function (m) {\n                return m.playing;\n              }).map(function (m) {\n                return m.name;\n              });\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"playingAnimationNames\", {\n            // Returns a list of playing animation names\n            get: function () {\n              // If the file's not loaded, we got nothing to return\n              if (!this.loaded) {\n                return [];\n              }\n\n              return this.animator.animations.filter(function (a) {\n                return a.playing;\n              }).map(function (a) {\n                return a.name;\n              });\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"pausedAnimationNames\", {\n            // Returns a list of paused animation names\n            get: function () {\n              // If the file's not loaded, we got nothing to return\n              if (!this.loaded) {\n                return [];\n              }\n\n              return this.animator.animations.filter(function (a) {\n                return !a.playing;\n              }).map(function (a) {\n                return a.name;\n              });\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"pausedStateMachineNames\", {\n            /**\n             *  Returns a list of paused machine names\n             * @returns a list of state machine names that are paused\n             */\n            get: function () {\n              // If the file's not loaded, we got nothing to return\n              if (!this.loaded) {\n                return [];\n              }\n\n              return this.animator.stateMachines.filter(function (m) {\n                return !m.playing;\n              }).map(function (m) {\n                return m.name;\n              });\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"isPlaying\", {\n            /**\n             * @returns true if any animation is playing\n             */\n            get: function () {\n              return this.animator.isPlaying;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"isPaused\", {\n            /**\n             * @returns true if all instanced animations are paused\n             */\n            get: function () {\n              return this.animator.isPaused;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"isStopped\", {\n            /**\n             * @returns true if no animations are playing or paused\n             */\n            get: function () {\n              return this.animator.isStopped;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          Object.defineProperty(Rive.prototype, \"bounds\", {\n            /**\n             * @returns the bounds of the current artboard, or undefined if the artboard\n             * isn't loaded yet.\n             */\n            get: function () {\n              return this.artboard ? this.artboard.bounds : undefined;\n            },\n            enumerable: false,\n            configurable: true\n          });\n          /**\n           * Subscribe to Rive-generated events\n           * @param type the type of event to subscribe to\n           * @param callback callback to fire when the event occurs\n           */\n\n          Rive.prototype.on = function (type, callback) {\n            this.eventManager.add({\n              type: type,\n              callback: callback\n            });\n          };\n          /**\n           * Unsubscribes from a Rive-generated event\n           * @param callback the callback to unsubscribe from\n           */\n\n\n          Rive.prototype.unsubscribe = function (type, callback) {\n            this.eventManager.remove({\n              type: type,\n              callback: callback\n            });\n          };\n          /**\n           * Unsubscribes all listeners from an event type, or everything if no type is\n           * given\n           * @param type the type of event to unsubscribe from, or all types if\n           * undefined\n           */\n\n\n          Rive.prototype.unsubscribeAll = function (type) {\n            this.eventManager.removeAll(type);\n          };\n          /**\n           * Stops the rendering loop; this is different from pausing in that it doesn't\n           * change the state of any animation. It stops rendering from occurring. This\n           * is designed for situations such as when Rive isn't visible.\n           *\n           * The only way to start rendering again is to call `startRendering`.\n           * Animations that are marked as playing will start from the position that\n           * they would have been at if rendering had not been stopped.\n           */\n\n\n          Rive.prototype.stopRendering = function () {\n            if (this.loaded && this.frameRequestId) {\n              if (this.runtime.cancelAnimationFrame) {\n                this.runtime.cancelAnimationFrame(this.frameRequestId);\n              } else {\n                cancelAnimationFrame(this.frameRequestId);\n              }\n\n              this.frameRequestId = null;\n            }\n          };\n          /**\n           * Starts the rendering loop if it has been previously stopped. If the\n           * renderer is already active, then this will have zero effect.\n           */\n\n\n          Rive.prototype.startRendering = function () {\n            if (this.loaded && this.artboard && !this.frameRequestId) {\n              if (this.runtime.requestAnimationFrame) {\n                this.frameRequestId = this.runtime.requestAnimationFrame(this.draw.bind(this));\n              } else {\n                this.frameRequestId = requestAnimationFrame(this.draw.bind(this));\n              }\n            }\n          };\n          /**\n           * Enables frames-per-second (FPS) reporting for the runtime\n           * If no callback is provided, Rive will append a fixed-position div at the top-right corner of\n           * the page with the FPS reading\n           * @param fpsCallback - Callback from the runtime during the RAF loop that supplies the FPS value\n           */\n\n\n          Rive.prototype.enableFPSCounter = function (fpsCallback) {\n            this.runtime.enableFPSCounter(fpsCallback);\n          };\n          /**\n           * Disables frames-per-second (FPS) reporting for the runtime\n           */\n\n\n          Rive.prototype.disableFPSCounter = function () {\n            this.runtime.disableFPSCounter();\n          };\n\n          Object.defineProperty(Rive.prototype, \"contents\", {\n            /**\n             * Returns the contents of a Rive file: the artboards, animations, and state machines\n             */\n            get: function () {\n              if (!this.loaded) {\n                return undefined;\n              }\n\n              var riveContents = {\n                artboards: []\n              };\n\n              for (var i = 0; i < this.file.artboardCount(); i++) {\n                var artboard = this.file.artboardByIndex(i);\n                var artboardContents = {\n                  name: artboard.name,\n                  animations: [],\n                  stateMachines: []\n                };\n\n                for (var j = 0; j < artboard.animationCount(); j++) {\n                  var animation = artboard.animationByIndex(j);\n                  artboardContents.animations.push(animation.name);\n                }\n\n                for (var k = 0; k < artboard.stateMachineCount(); k++) {\n                  var stateMachine = artboard.stateMachineByIndex(k);\n                  var name_1 = stateMachine.name;\n                  var instance = new this.runtime.StateMachineInstance(stateMachine, artboard);\n                  var inputContents = [];\n\n                  for (var l = 0; l < instance.inputCount(); l++) {\n                    var input = instance.input(l);\n                    inputContents.push({\n                      name: input.name,\n                      type: input.type\n                    });\n                  }\n\n                  artboardContents.stateMachines.push({\n                    name: name_1,\n                    inputs: inputContents\n                  });\n                }\n\n                riveContents.artboards.push(artboardContents);\n              }\n\n              return riveContents;\n            },\n            enumerable: false,\n            configurable: true\n          }); // Error message for missing source or buffer\n\n          Rive.missingErrorMessage = \"Rive source file or data buffer required\";\n          return Rive;\n        }(); // Loads Rive data from a URI via fetch.\n\n\n        var loadRiveFile = function (src) {\n          return __awaiter(void 0, void 0, void 0, function () {\n            var req, res, buffer;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  req = new Request(src);\n                  return [4\n                  /*yield*/\n                  , fetch(req)];\n\n                case 1:\n                  res = _a.sent();\n                  return [4\n                  /*yield*/\n                  , res.arrayBuffer()];\n\n                case 2:\n                  buffer = _a.sent();\n                  return [2\n                  /*return*/\n                  , buffer];\n              }\n            });\n          });\n        }; // #endregion\n        // #region utility functions\n\n        /*\n         * Utility function to ensure an object is a string array\n         */\n\n\n        var mapToStringArray = function (obj) {\n          if (typeof obj === \"string\") {\n            return [obj];\n          } else if (obj instanceof Array) {\n            return obj;\n          } // If obj is undefined, return empty array\n\n\n          return [];\n        }; // #endregion\n        // #region testing utilities\n        // Exports to only be used for tests\n\n\n        var Testing = {\n          EventManager: EventManager,\n          TaskQueueManager: TaskQueueManager\n        }; // #endregion\n      })();\n      /******/\n\n\n      return __webpack_exports__;\n      /******/\n    })()\n  );\n}); //# sourceMappingURL=rive.js.map","map":null,"metadata":{},"sourceType":"script"}