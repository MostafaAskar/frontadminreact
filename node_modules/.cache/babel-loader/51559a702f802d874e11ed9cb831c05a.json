{"ast":null,"code":"import { initializeApp } from 'firebase/app';\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\nimport { getFirestore, collection, onSnapshot, query, orderBy, addDoc, serverTimestamp, updateDoc, doc, deleteDoc, where, writeBatch } from 'firebase/firestore';\nimport { batch as reduxBatch } from 'react-redux';\nimport { API_KEY, APP_ID, AUTH_DOMAIN, MEASUREMENT_ID, MESSAGING_SENDER_ID, PROJECT_ID, STORAGE_BUCKET, VAPID_KEY } from './configs/app-global';\nimport { store } from './redux/store';\nimport { setChats, setMessages, setMessagesLoading } from './redux/slices/chat';\nimport { toast } from 'react-toastify';\nimport userService from './services/seller/user';\nimport { getStorage } from 'firebase/storage';\nimport { setFirebaseToken } from './redux/slices/auth';\nimport chatService from './services/chat';\nconst firebaseConfig = {\n  apiKey: API_KEY,\n  authDomain: AUTH_DOMAIN,\n  projectId: PROJECT_ID,\n  storageBucket: STORAGE_BUCKET,\n  messagingSenderId: MESSAGING_SENDER_ID,\n  appId: APP_ID,\n  measurementId: MEASUREMENT_ID\n};\nconst app = initializeApp(firebaseConfig);\nconst messaging = getMessaging();\nconst db = getFirestore(app);\nexport const storage = getStorage(app);\n\nfunction buildChatList(userDataList, firebaseChatList) {\n  // reverse array for searching from end to beginning;\n  firebaseChatList.reverse();\n  return userDataList.map(userDataItem => {\n    const chatItem = firebaseChatList.find(item => item.ids.includes(userDataItem.id));\n    chatItem.user = userDataItem;\n    return chatItem;\n  });\n}\n\nexport function getChat(currentUserId) {\n  try {\n    const chatCollectionRef = collection(db, 'chat');\n    const chatQuery = query(chatCollectionRef, where('ids', 'array-contains', currentUserId));\n    return onSnapshot(chatQuery, chatSnapshot => {\n      const firebaseChats = chatSnapshot.docs.map(doc => ({\n        chatId: doc.id,\n        ...doc.data()\n      }));\n      const userIds = firebaseChats.map(firebaseChat => firebaseChat.ids.filter(id => id !== currentUserId)[0]).filter(Boolean);\n      chatService.getUser({\n        ids: [...new Set(userIds)]\n      }).then(res => {\n        store.dispatch(setChats(buildChatList(res.data, firebaseChats)));\n      });\n    });\n  } catch (error) {\n    console.error(error);\n  }\n}\nexport function fetchMessages(chatId, userId) {\n  if (!chatId) return null;\n\n  try {\n    const q = query(collection(db, 'chat', chatId, 'message'), orderBy('time'));\n    return onSnapshot(q, async querySnapshot => {\n      const fetchedMessages = [];\n      const batch = writeBatch(db);\n      querySnapshot.forEach(doc => {\n        const messageRef = doc.ref;\n        const message = doc.data();\n        fetchedMessages.push({\n          id: doc.id,\n          message: message.message,\n          time: message.time,\n          read: message.read,\n          senderId: message.senderId,\n          type: message.type,\n          replyDocId: message.replyDocId,\n          isLast: false\n        });\n\n        if (message.senderId !== userId && !message.read) {\n          batch.update(messageRef, {\n            read: true\n          });\n        }\n      });\n      fetchedMessages.sort((a, b) => new Date(a.time) - new Date(b.time));\n\n      if (fetchedMessages[querySnapshot.size - 1]) {\n        fetchedMessages[querySnapshot.size - 1].isLast = true;\n      }\n\n      reduxBatch(() => {\n        store.dispatch(setMessagesLoading(false));\n        store.dispatch(setMessages(fetchedMessages));\n      });\n      await batch.commit();\n    });\n  } catch (error) {\n    console.error(error);\n  }\n}\nexport async function sendMessage(currentUserId, chatId, payload) {\n  if (!chatId || !currentUserId) return null;\n\n  try {\n    const chatRef = doc(db, 'chat', chatId);\n    await updateDoc(chatRef, {\n      lastMessage: payload.message,\n      time: serverTimestamp()\n    });\n    const body = {\n      read: false,\n      time: new Date().toISOString(),\n      senderId: currentUserId,\n      ...payload\n    };\n\n    if (payload.type) {\n      body.type = payload.type;\n    }\n\n    await addDoc(collection(db, 'chat', chatId, 'message'), body);\n  } catch (error) {\n    toast.error(error.message);\n    console.error(error);\n  }\n}\nexport async function editMessage(currentUserId, chatId, payload, editingMessage) {\n  if (!chatId || !currentUserId || !editingMessage || !payload) return null;\n\n  try {\n    const messageRef = doc(db, 'chat', chatId, 'message', editingMessage.message.id);\n\n    if (editingMessage.message.isLast) {\n      await updateDoc(doc(db, 'chat', chatId), {\n        lastMessage: payload.message,\n        time: serverTimestamp()\n      });\n    }\n\n    await updateDoc(messageRef, {\n      message: payload.message\n    });\n  } catch (error) {\n    toast.error(error.message);\n    console.error(error);\n  }\n}\nexport async function deleteChat(currentChatId) {\n  try {\n    await deleteDoc(doc(db, 'chat', currentChatId));\n  } catch (error) {\n    toast.error(error);\n  }\n}\nexport async function deleteMessage(chatId, message, messageBeforeLastMessage) {\n  if (!chatId || !message) return null;\n\n  try {\n    await deleteDoc(doc(db, 'chat', chatId, 'message', message.id));\n\n    if (message.isLast) {\n      await updateDoc(doc(db, 'chat', chatId), {\n        lastMessage: messageBeforeLastMessage ? messageBeforeLastMessage.message : '',\n        time: serverTimestamp()\n      });\n    }\n  } catch (error) {\n    console.error(error);\n    toast.error(error);\n  }\n}\nexport async function fetchRepliedMessage(messageId, currentChatId, setReplyMessage) {\n  if (currentChatId) {\n    const q = doc(db, 'chat', currentChatId, 'message', messageId);\n    return onSnapshot(q, snapshot => {\n      const message = snapshot.data();\n      setReplyMessage({\n        id: snapshot.id,\n        message: message === null || message === void 0 ? void 0 : message.message,\n        type: message === null || message === void 0 ? void 0 : message.type\n      });\n    });\n  }\n}\nexport const requestForToken = () => {\n  return getToken(messaging, {\n    vapidKey: VAPID_KEY\n  }).then(currentToken => {\n    if (currentToken) {\n      store.dispatch(setFirebaseToken(currentToken));\n      const payload = {\n        firebase_token: currentToken\n      };\n      userService.profileFirebaseToken(payload).then(res => console.log('firebase token sent => ', res));\n    } else {\n      // Show permission request UI\n      console.log('No registration token available. Request permission to generate one.');\n    }\n  }).catch(err => {\n    console.log('An error occurred while retrieving token. ', err);\n  });\n};\nexport const onMessageListener = () => new Promise(resolve => {\n  onMessage(messaging, payload => {\n    resolve(payload);\n  });\n});","map":{"version":3,"names":["initializeApp","getMessaging","getToken","onMessage","getFirestore","collection","onSnapshot","query","orderBy","addDoc","serverTimestamp","updateDoc","doc","deleteDoc","where","writeBatch","batch","reduxBatch","API_KEY","APP_ID","AUTH_DOMAIN","MEASUREMENT_ID","MESSAGING_SENDER_ID","PROJECT_ID","STORAGE_BUCKET","VAPID_KEY","store","setChats","setMessages","setMessagesLoading","toast","userService","getStorage","setFirebaseToken","chatService","firebaseConfig","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","measurementId","app","messaging","db","storage","buildChatList","userDataList","firebaseChatList","reverse","map","userDataItem","chatItem","find","item","ids","includes","id","user","getChat","currentUserId","chatCollectionRef","chatQuery","chatSnapshot","firebaseChats","docs","chatId","data","userIds","firebaseChat","filter","Boolean","getUser","Set","then","res","dispatch","error","console","fetchMessages","userId","q","querySnapshot","fetchedMessages","forEach","messageRef","ref","message","push","time","read","senderId","type","replyDocId","isLast","update","sort","a","b","Date","size","commit","sendMessage","payload","chatRef","lastMessage","body","toISOString","editMessage","editingMessage","deleteChat","currentChatId","deleteMessage","messageBeforeLastMessage","fetchRepliedMessage","messageId","setReplyMessage","snapshot","requestForToken","vapidKey","currentToken","firebase_token","profileFirebaseToken","log","catch","err","onMessageListener","Promise","resolve"],"sources":["/home/mostafa/Magde/new uzmart/admin/uzmart-admin-main/src/firebase.js"],"sourcesContent":["import { initializeApp } from 'firebase/app';\nimport { getMessaging, getToken, onMessage } from 'firebase/messaging';\nimport {\n  getFirestore,\n  collection,\n  onSnapshot,\n  query,\n  orderBy,\n  addDoc,\n  serverTimestamp,\n  updateDoc,\n  doc,\n  deleteDoc,\n  where,\n  writeBatch,\n} from 'firebase/firestore';\nimport { batch as reduxBatch } from 'react-redux';\nimport {\n  API_KEY,\n  APP_ID,\n  AUTH_DOMAIN,\n  MEASUREMENT_ID,\n  MESSAGING_SENDER_ID,\n  PROJECT_ID,\n  STORAGE_BUCKET,\n  VAPID_KEY,\n} from './configs/app-global';\nimport { store } from './redux/store';\nimport { setChats, setMessages, setMessagesLoading } from './redux/slices/chat';\nimport { toast } from 'react-toastify';\nimport userService from './services/seller/user';\nimport { getStorage } from 'firebase/storage';\nimport { setFirebaseToken } from './redux/slices/auth';\nimport chatService from './services/chat';\n\nconst firebaseConfig = {\n  apiKey: API_KEY,\n  authDomain: AUTH_DOMAIN,\n  projectId: PROJECT_ID,\n  storageBucket: STORAGE_BUCKET,\n  messagingSenderId: MESSAGING_SENDER_ID,\n  appId: APP_ID,\n  measurementId: MEASUREMENT_ID,\n};\n\nconst app = initializeApp(firebaseConfig);\n\nconst messaging = getMessaging();\nconst db = getFirestore(app);\nexport const storage = getStorage(app);\n\nfunction buildChatList(userDataList, firebaseChatList) {\n  // reverse array for searching from end to beginning;\n  firebaseChatList.reverse();\n\n  return userDataList.map((userDataItem) => {\n    const chatItem = firebaseChatList.find((item) =>\n      item.ids.includes(userDataItem.id),\n    );\n    chatItem.user = userDataItem;\n    return chatItem;\n  });\n}\n\nexport function getChat(currentUserId) {\n  try {\n    const chatCollectionRef = collection(db, 'chat');\n    const chatQuery = query(\n      chatCollectionRef,\n      where('ids', 'array-contains', currentUserId),\n    );\n\n    return onSnapshot(chatQuery, (chatSnapshot) => {\n      const firebaseChats = chatSnapshot.docs.map((doc) => ({\n        chatId: doc.id,\n        ...doc.data(),\n      }));\n\n      const userIds = firebaseChats\n        .map(\n          (firebaseChat) =>\n            firebaseChat.ids.filter((id) => id !== currentUserId)[0],\n        )\n        .filter(Boolean);\n\n      chatService\n        .getUser({\n          ids: [...new Set(userIds)],\n        })\n        .then((res) => {\n          store.dispatch(setChats(buildChatList(res.data, firebaseChats)));\n        });\n    });\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nexport function fetchMessages(chatId, userId) {\n  if (!chatId) return null;\n  try {\n    const q = query(collection(db, 'chat', chatId, 'message'), orderBy('time'));\n\n    return onSnapshot(q, async (querySnapshot) => {\n      const fetchedMessages = [];\n      const batch = writeBatch(db);\n      querySnapshot.forEach((doc) => {\n        const messageRef = doc.ref;\n        const message = doc.data();\n        fetchedMessages.push({\n          id: doc.id,\n          message: message.message,\n          time: message.time,\n          read: message.read,\n          senderId: message.senderId,\n          type: message.type,\n          replyDocId: message.replyDocId,\n          isLast: false,\n        });\n\n        if (message.senderId !== userId && !message.read) {\n          batch.update(messageRef, {\n            read: true,\n          });\n        }\n      });\n      fetchedMessages.sort((a, b) => new Date(a.time) - new Date(b.time));\n      if (fetchedMessages[querySnapshot.size - 1]) {\n        fetchedMessages[querySnapshot.size - 1].isLast = true;\n      }\n      reduxBatch(() => {\n        store.dispatch(setMessagesLoading(false));\n        store.dispatch(setMessages(fetchedMessages));\n      });\n      await batch.commit();\n    });\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nexport async function sendMessage(currentUserId, chatId, payload) {\n  if (!chatId || !currentUserId) return null;\n  try {\n    const chatRef = doc(db, 'chat', chatId);\n\n    await updateDoc(chatRef, {\n      lastMessage: payload.message,\n      time: serverTimestamp(),\n    });\n\n    const body = {\n      read: false,\n      time: new Date().toISOString(),\n      senderId: currentUserId,\n      ...payload,\n    };\n\n    if (payload.type) {\n      body.type = payload.type;\n    }\n\n    await addDoc(collection(db, 'chat', chatId, 'message'), body);\n  } catch (error) {\n    toast.error(error.message);\n    console.error(error);\n  }\n}\n\nexport async function editMessage(\n  currentUserId,\n  chatId,\n  payload,\n  editingMessage,\n) {\n  if (!chatId || !currentUserId || !editingMessage || !payload) return null;\n  try {\n    const messageRef = doc(\n      db,\n      'chat',\n      chatId,\n      'message',\n      editingMessage.message.id,\n    );\n    if (editingMessage.message.isLast) {\n      await updateDoc(doc(db, 'chat', chatId), {\n        lastMessage: payload.message,\n        time: serverTimestamp(),\n      });\n    }\n    await updateDoc(messageRef, {\n      message: payload.message,\n    });\n  } catch (error) {\n    toast.error(error.message);\n    console.error(error);\n  }\n}\n\nexport async function deleteChat(currentChatId) {\n  try {\n    await deleteDoc(doc(db, 'chat', currentChatId));\n  } catch (error) {\n    toast.error(error);\n  }\n}\n\nexport async function deleteMessage(chatId, message, messageBeforeLastMessage) {\n  if (!chatId || !message) return null;\n  try {\n    await deleteDoc(doc(db, 'chat', chatId, 'message', message.id));\n    if (message.isLast) {\n      await updateDoc(doc(db, 'chat', chatId), {\n        lastMessage: messageBeforeLastMessage\n          ? messageBeforeLastMessage.message\n          : '',\n        time: serverTimestamp(),\n      });\n    }\n  } catch (error) {\n    console.error(error);\n    toast.error(error);\n  }\n}\n\nexport async function fetchRepliedMessage(\n  messageId,\n  currentChatId,\n  setReplyMessage,\n) {\n  if (currentChatId) {\n    const q = doc(db, 'chat', currentChatId, 'message', messageId);\n    return onSnapshot(q, (snapshot) => {\n      const message = snapshot.data();\n      setReplyMessage({\n        id: snapshot.id,\n        message: message?.message,\n        type: message?.type,\n      });\n    });\n  }\n}\n\nexport const requestForToken = () => {\n  return getToken(messaging, { vapidKey: VAPID_KEY })\n    .then((currentToken) => {\n      if (currentToken) {\n        store.dispatch(setFirebaseToken(currentToken));\n        const payload = { firebase_token: currentToken };\n        userService\n          .profileFirebaseToken(payload)\n          .then((res) => console.log('firebase token sent => ', res));\n      } else {\n        // Show permission request UI\n        console.log(\n          'No registration token available. Request permission to generate one.',\n        );\n      }\n    })\n    .catch((err) => {\n      console.log('An error occurred while retrieving token. ', err);\n    });\n};\n\nexport const onMessageListener = () =>\n  new Promise((resolve) => {\n    onMessage(messaging, (payload) => {\n      resolve(payload);\n    });\n  });\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}